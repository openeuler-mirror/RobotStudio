// @generated by protobuf-ts 2.9.0 with parameter use_proto_field_name
// @generated from protobuf file "robot_grpc_service.proto" (package "rosc", syntax proto3)
// tslint:disable
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message rosc.PingResponse
 */
export interface PingResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.PowerOnResponse
 */
export interface PowerOnResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.PowerOffResponse
 */
export interface PowerOffResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.ClearErrorResponse
 */
export interface ClearErrorResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.EmergencyStopRequest
 */
export interface EmergencyStopRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.EmergencyStopResponse
 */
export interface EmergencyStopResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.EmergencyRecoverRequest
 */
export interface EmergencyRecoverRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.EmergencyRecoverResponse
 */
export interface EmergencyRecoverResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.TeachMoveStepRequest
 */
export interface TeachMoveStepRequest {
    /**
     * @generated from protobuf field: rosc.GRPCAxisNum axis = 1;
     */
    axis: GRPCAxisNum; // /< 指定轴    /**
     * @generated from protobuf field: int32 direction = 2;
     */
    direction: number; // /< 指定方向    /**
     * @generated from protobuf field: double jog_step = 3;
     */
    jog_step: number; // /< 指定}
/**
 * @generated from protobuf message rosc.TeachMoveStepResponse
 */
export interface TeachMoveStepResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.TeachJogStartRequest
 */
export interface TeachJogStartRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: int32 axis = 3;
     */
    axis: number;
    /**
     * @generated from protobuf field: int32 direction = 4;
     */
    direction: number;
    /**
     * @generated from protobuf field: double jog_step = 5;
     */
    jog_step: number;
    /**
     * @generated from protobuf field: optional rosc.JogVelocityLevel velocity_level = 6;
     */
    velocity_level?: JogVelocityLevel;
}
/**
 * @generated from protobuf message rosc.TeachJogStartResponse
 */
export interface TeachJogStartResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.TeachJogStopRequest
 */
export interface TeachJogStopRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.TeachJogStopResponse
 */
export interface TeachJogStopResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.TeachStreamStartGetJointsResponse
 */
export interface TeachStreamStartGetJointsResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated double joints = 3;
     */
    joints: number[]; // 关节信息    /**
     * @generated from protobuf field: string servo_state = 4;
     */
    servo_state: string; // 伺服状态信息    /**
     * @generated from protobuf field: repeated double left_arm = 5;
     */
    left_arm: number[]; // 左臂的笛卡尔坐标    /**
     * @generated from protobuf field: repeated double right_arm = 6;
     */
    right_arm: number[]; // 右臂的笛卡尔坐标    /**
     * @generated from protobuf field: repeated double velocitys = 7;
     */
    velocitys: number[]; // 实时速度    /**
     * @generated from protobuf field: repeated double a = 8;
     */
    a: number[]; // 前端机器人模型显示运动的点位    /**
     * @generated from protobuf field: repeated double b = 9;
     */
    b: number[];
    /**
     * @generated from protobuf field: repeated double c = 10;
     */
    c: number[];
    /**
     * @generated from protobuf field: repeated double d = 11;
     */
    d: number[];
}
/**
 * @generated from protobuf message rosc.TeachStreamStopGetJointsResponse
 */
export interface TeachStreamStopGetJointsResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.TeachBoardStartStatusStreamResponse
 */
export interface TeachBoardStartStatusStreamResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated double joints = 3;
     */
    joints: number[]; // 关节信息    /**
     * @generated from protobuf field: string servo_state = 4;
     */
    servo_state: string; // 伺服状态信息    /**
     * @generated from protobuf field: repeated double left_arm = 5;
     */
    left_arm: number[]; // 左臂的笛卡尔坐标    /**
     * @generated from protobuf field: repeated double right_arm = 6;
     */
    right_arm: number[]; // 右臂的笛卡尔坐标    /**
     * @generated from protobuf field: repeated double velocitys = 7;
     */
    velocitys: number[]; // 实时速度    /**
     * @generated from protobuf field: bool digit_io_out_r1 = 8;
     */
    digit_io_out_r1: boolean; // 数字io输出的状态监控（用于控制blade是否吸附）    /**
     * @generated from protobuf field: bool digit_io_out_r2 = 9;
     */
    digit_io_out_r2: boolean; // 数字io输出的状态监控    /**
     * @generated from protobuf field: bool digit_io_in_r1 = 10;
     */
    digit_io_in_r1: boolean; // 数字io外部输入信息的监控（例如红外传感器判断是否）    /**
     * @generated from protobuf field: bool digit_io_in_r2 = 11;
     */
    digit_io_in_r2: boolean; // 数字io外部输入信息的监控（例如红外传感器判断是否）}
/**
 * @generated from protobuf message rosc.TeachBoardStopStatusStreamResponse
 */
export interface TeachBoardStopStatusStreamResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.TeachSavePositionRequest
 */
export interface TeachSavePositionRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
    /**
     * @generated from protobuf field: string describe = 4;
     */
    describe: string;
    /**
     * @generated from protobuf field: string arm = 5;
     */
    arm: string;
    /**
     * @generated from protobuf field: int32 slot = 6;
     */
    slot: number;
    /**
     * @generated from protobuf field: int32 has_mid = 7;
     */
    has_mid: number;
}
/**
 * @generated from protobuf message rosc.TeachSavePositionResponse
 */
export interface TeachSavePositionResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated double joints = 3;
     */
    joints: number[];
}
/**
 * @generated from protobuf message rosc.TeachSetVelocityRequest
 */
export interface TeachSetVelocityRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: int32 velocity = 3;
     */
    velocity: number;
}
/**
 * @generated from protobuf message rosc.TeachSetVelocityResponse
 */
export interface TeachSetVelocityResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.TeachGetVelocityRequest
 */
export interface TeachGetVelocityRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.TeachGetVelocityResponse
 */
export interface TeachGetVelocityResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: int32 velocity = 3;
     */
    velocity: number;
}
/**
 * @generated from protobuf message rosc.SetJogVelocityLevelRequest
 */
export interface SetJogVelocityLevelRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * jog的速度等级。目前并不支持每个轴设置不同的速度等级。
     *
     * @generated from protobuf field: rosc.JogVelocityLevel velocity_level = 3;
     */
    velocity_level: JogVelocityLevel;
}
/**
 * @generated from protobuf message rosc.JogVelocityResponse
 */
export interface JogVelocityResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated int32 velocity = 3;
     */
    velocity: number[]; // 每个轴的速度    /**
     * 机器人的jog速度level，如果jog速度没有匹配对应的level，则level返回UNKNOW。
     * 每个轴都匹配对应配置的速度等级，才会返回有效的速度level
     *
     * @generated from protobuf field: rosc.JogVelocityLevel velocity_level = 4;
     */
    velocity_level: JogVelocityLevel;
}
/**
 * @generated from protobuf message rosc.TeachMoveRequest
 */
export interface TeachMoveRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message rosc.TeachMoveResponse
 */
export interface TeachMoveResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.SetIOOutputStateRequest
 */
export interface SetIOOutputStateRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: int32 serial = 3;
     */
    serial: number;
    /**
     * @generated from protobuf field: bool state = 4;
     */
    state: boolean;
}
/**
 * @generated from protobuf message rosc.SetIOOutputStateResponse
 */
export interface SetIOOutputStateResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetIOOutputStateRequest
 */
export interface GetIOOutputStateRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetIOOutputStateResponse
 */
export interface GetIOOutputStateResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated bool states = 3;
     */
    states: boolean[];
    /**
     * @generated from protobuf field: repeated string describes = 4;
     */
    describes: string[];
    /**
     * @generated from protobuf field: repeated bool enable = 5;
     */
    enable: boolean[];
}
/**
 * @generated from protobuf message rosc.GetIOInputStateRequest
 */
export interface GetIOInputStateRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetIOInputStateResponse
 */
export interface GetIOInputStateResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated bool states = 3;
     */
    states: boolean[];
    /**
     * @generated from protobuf field: repeated string describes = 4;
     */
    describes: string[];
    /**
     * @generated from protobuf field: repeated bool enable = 5;
     */
    enable: boolean[];
}
/**
 * @generated from protobuf message rosc.StopGetIOInputStateRequest
 */
export interface StopGetIOInputStateRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.StopGetIOInputStateResponse
 */
export interface StopGetIOInputStateResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.DeletePointRequest
 */
export interface DeletePointRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message rosc.DeletePointResponse
 */
export interface DeletePointResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetAllPointNamesRequest
 */
export interface GetAllPointNamesRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetAllPointNamesResponse
 */
export interface GetAllPointNamesResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated string point_names = 3;
     */
    point_names: string[];
}
/**
 * @generated from protobuf message rosc.DownloadPointFileRequest
 */
export interface DownloadPointFileRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.DownloadPointFileResponse
 */
export interface DownloadPointFileResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: bytes data = 3;
     */
    data: Uint8Array;
}
/**
 * @generated from protobuf message rosc.MoveToTeachPositionRequest
 */
export interface MoveToTeachPositionRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string name = 3;
     */
    name: string;
}
/**
 * @generated from protobuf message rosc.MoveToTeachPositionResponse
 */
export interface MoveToTeachPositionResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GoTeachJointRequest
 */
export interface GoTeachJointRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string point_name = 3;
     */
    point_name: string;
}
/**
 * @generated from protobuf message rosc.GoTeachJointResponse
 */
export interface GoTeachJointResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetStreamExceptionRequest
 */
export interface GetStreamExceptionRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetStreamExceptionResponse
 */
export interface GetStreamExceptionResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string status_code = 3;
     */
    status_code: string;
    /**
     * @generated from protobuf field: int32 level = 4;
     */
    level: number;
    /**
     * @generated from protobuf field: string time = 5;
     */
    time: string;
    /**
     * @generated from protobuf field: string message = 6;
     */
    message: string;
}
/**
 * @generated from protobuf message rosc.GetExceptionRequest
 */
export interface GetExceptionRequest {
}
/**
 * @generated from protobuf message rosc.GetExceptionResponse
 */
export interface GetExceptionResponse {
    /**
     * @generated from protobuf field: repeated string status_code = 1;
     */
    status_code: string[];
    /**
     * @generated from protobuf field: repeated int32 level = 2;
     */
    level: number[];
    /**
     * @generated from protobuf field: repeated string time = 3;
     */
    time: string[];
    /**
     * @generated from protobuf field: repeated string message = 4;
     */
    message: string[];
}
/**
 * @generated from protobuf message rosc.DeleteExceptionRequest
 */
export interface DeleteExceptionRequest {
}
/**
 * @generated from protobuf message rosc.DeleteExceptionResponse
 */
export interface DeleteExceptionResponse {
}
/**
 * @generated from protobuf message rosc.DeviceSetting
 */
export interface DeviceSetting {
    /**
     * @generated from protobuf field: int32 dof = 1;
     */
    dof: number;
    /**
     * @generated from protobuf field: int32 IO = 2 [json_name = "IO"];
     */
    IO: number;
    /**
     * @generated from protobuf field: double speed = 3;
     */
    speed: number;
}
/**
 * @generated from protobuf message rosc.JointSetting
 */
export interface JointSetting {
    /**
     * @generated from protobuf field: repeated string joint_name = 1;
     */
    joint_name: string[];
    /**
     * @generated from protobuf field: repeated double vel_max = 2;
     */
    vel_max: number[];
    /**
     * @generated from protobuf field: repeated double acc_max = 3;
     */
    acc_max: number[];
    /**
     * @generated from protobuf field: repeated double jerk = 4;
     */
    jerk: number[];
    /**
     * @generated from protobuf field: repeated double MotionRangeStart = 5 [json_name = "MotionRangeStart"];
     */
    MotionRangeStart: number[];
    /**
     * @generated from protobuf field: repeated double MotionRangeEnd = 6 [json_name = "MotionRangeEnd"];
     */
    MotionRangeEnd: number[];
    /**
     * @generated from protobuf field: repeated double dcc_max = 7;
     */
    dcc_max: number[];
    /**
     * @generated from protobuf field: repeated double dcc_jerk = 8;
     */
    dcc_jerk: number[];
}
/**
 * @generated from protobuf message rosc.IOSetting
 */
export interface IOSetting {
    /**
     * @generated from protobuf field: int32 IO_seq_l = 1 [json_name = "IOSeqL"];
     */
    IO_seq_l: number;
    /**
     * @generated from protobuf field: int32 IO_seq_r = 2 [json_name = "IOSeqR"];
     */
    IO_seq_r: number;
    /**
     * @generated from protobuf field: int32 wafer_confirm_out_l = 3;
     */
    wafer_confirm_out_l: number;
    /**
     * @generated from protobuf field: int32 wafer_confirm_out_r = 4;
     */
    wafer_confirm_out_r: number;
    /**
     * @generated from protobuf field: int32 user_mode = 5;
     */
    user_mode: number;
    /**
     * @generated from protobuf field: int32 err_signal = 6;
     */
    err_signal: number;
    /**
     * @generated from protobuf field: int32 ready_signal = 7;
     */
    ready_signal: number;
    /**
     * @generated from protobuf field: int32 PA_ready_signal = 8 [json_name = "PAReadySignal"];
     */
    PA_ready_signal: number;
    /**
     * @generated from protobuf field: int32 wafer_sensor_l = 9;
     */
    wafer_sensor_l: number;
    /**
     * @generated from protobuf field: int32 wafer_sensor_r = 10;
     */
    wafer_sensor_r: number;
    /**
     * @generated from protobuf field: int32 mapping_sensor = 11;
     */
    mapping_sensor: number;
    /**
     * @generated from protobuf field: int32 wafer_sensor_lr = 12;
     */
    wafer_sensor_lr: number;
    /**
     * @generated from protobuf field: int32 wafer_sensor_rr = 13;
     */
    wafer_sensor_rr: number;
    /**
     * @generated from protobuf field: int32 IO_seq_lr = 14 [json_name = "IOSeqLr"];
     */
    IO_seq_lr: number;
    /**
     * @generated from protobuf field: int32 IO_seq_rr = 15 [json_name = "IOSeqRr"];
     */
    IO_seq_rr: number;
    /**
     * @generated from protobuf field: int32 wafer_confirm_out_lr = 16;
     */
    wafer_confirm_out_lr: number;
    /**
     * @generated from protobuf field: int32 wafer_confirm_out_rr = 17;
     */
    wafer_confirm_out_rr: number;
}
/**
 * @generated from protobuf message rosc.SaveJointSettingItem
 */
export interface SaveJointSettingItem {
    /**
     * @generated from protobuf field: string axis_name = 1;
     */
    axis_name: string;
    /**
     * @generated from protobuf field: string attribute = 2;
     */
    attribute: string;
    /**
     * @generated from protobuf field: double value = 3;
     */
    value: number;
}
/**
 * @generated from protobuf message rosc.SaveJointSettingRequest
 */
export interface SaveJointSettingRequest {
    /**
     * @generated from protobuf field: repeated rosc.SaveJointSettingItem data = 1;
     */
    data: SaveJointSettingItem[];
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 3;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.SaveJointSettingResponse
 */
export interface SaveJointSettingResponse {
    /**
     * @generated from protobuf field: string reply = 2;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 3;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.SaveIOSettingItem
 */
export interface SaveIOSettingItem {
    /**
     * @generated from protobuf field: string attribute = 1;
     */
    attribute: string;
    /**
     * @generated from protobuf field: int32 value = 2;
     */
    value: number;
}
/**
 * @generated from protobuf message rosc.SaveIOSettingRequest
 */
export interface SaveIOSettingRequest {
    /**
     * @generated from protobuf field: repeated rosc.SaveIOSettingItem data = 1;
     */
    data: SaveIOSettingItem[];
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 3;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.SaveIOSettingResponse
 */
export interface SaveIOSettingResponse {
    /**
     * @generated from protobuf field: string reply = 2;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 3;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.RobotSettingRequest
 */
export interface RobotSettingRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string setting_type = 3;
     */
    setting_type: string;
}
/**
 * @generated from protobuf message rosc.RobotSettingResponse
 */
export interface RobotSettingResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string setting_type = 3;
     */
    setting_type: string;
    /**
     * @generated from protobuf field: rosc.JointSetting joint_setting = 4;
     */
    joint_setting?: JointSetting;
    /**
     * @generated from protobuf field: rosc.DeviceSetting device_setting = 5;
     */
    device_setting?: DeviceSetting;
    /**
     * @generated from protobuf field: rosc.IOSetting io_setting = 6;
     */
    io_setting?: IOSetting;
}
/**
 * *
 * 获取轴的配置信息返回值
 *
 * @generated from protobuf message rosc.GetJointSettingResponse
 */
export interface GetJointSettingResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: rosc.JointSetting joint_setting = 3;
     */
    joint_setting?: JointSetting;
}
/**
 * *
 * 获得设备的配置信息返回值
 *
 * @generated from protobuf message rosc.GetDeviceSettingResponse
 */
export interface GetDeviceSettingResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: rosc.DeviceSetting device_setting = 5;
     */
    device_setting?: DeviceSetting;
}
/**
 * *
 * 获取IO的配置信息返回值
 *
 * @generated from protobuf message rosc.GetIOSettingResponse
 */
export interface GetIOSettingResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: rosc.IOSetting io_setting = 6;
     */
    io_setting?: IOSetting;
}
/**
 * @generated from protobuf message rosc.TeachInstructionRequest
 */
export interface TeachInstructionRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string op_type = 3;
     */
    op_type: string;
    /**
     * @generated from protobuf field: int32 speed = 4;
     */
    speed: number;
    /**
     * @generated from protobuf field: string start_point = 5;
     */
    start_point: string;
    /**
     * @generated from protobuf field: string mid_point = 6;
     */
    mid_point: string;
    /**
     * @generated from protobuf field: string end_point = 7;
     */
    end_point: string;
    /**
     * @generated from protobuf field: int32 sleep_time = 8;
     */
    sleep_time: number;
    /**
     * @generated from protobuf field: string arm = 9;
     */
    arm: string;
    /**
     * @generated from protobuf field: string fixBlade = 10;
     */
    fixBlade: string;
}
/**
 * @generated from protobuf message rosc.TeachInstructionResponse
 */
export interface TeachInstructionResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetPutWaferRequest
 */
export interface GetPutWaferRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: int32 start_arm = 3;
     */
    start_arm: number;
    /**
     * @generated from protobuf field: string start_cassette = 4;
     */
    start_cassette: string;
    /**
     * @generated from protobuf field: int32 start_slot = 5;
     */
    start_slot: number;
    /**
     * @generated from protobuf field: string end_cassette = 6;
     */
    end_cassette: string;
    /**
     * @generated from protobuf field: int32 end_slot = 7;
     */
    end_slot: number;
    /**
     * @generated from protobuf field: string start_arm_posture = 8;
     */
    start_arm_posture: string;
    /**
     * @generated from protobuf field: int32 end_arm = 9;
     */
    end_arm: number;
    /**
     * @generated from protobuf field: string end_arm_posture = 10;
     */
    end_arm_posture: string;
}
/**
 * @generated from protobuf message rosc.GetPutWaferResponse
 */
export interface GetPutWaferResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetPutWaferStopRequest
 */
export interface GetPutWaferStopRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetPutWaferStopResponse
 */
export interface GetPutWaferStopResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.OperateWaferRequest
 */
export interface OperateWaferRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string type = 3;
     */
    type: string;
    /**
     * @generated from protobuf field: int32 arm = 4;
     */
    arm: number;
    /**
     * @generated from protobuf field: string aim_point = 5;
     */
    aim_point: string;
    /**
     * @generated from protobuf field: int32 aim_slot = 6;
     */
    aim_slot: number;
    /**
     * @generated from protobuf field: string arm_posture = 7;
     */
    arm_posture: string;
}
/**
 * @generated from protobuf message rosc.OperateWaferResponse
 */
export interface OperateWaferResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.DebugWaferRequest
 */
export interface DebugWaferRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string type = 3;
     */
    type: string;
    /**
     * @generated from protobuf field: int32 arm = 4;
     */
    arm: number;
    /**
     * @generated from protobuf field: string aim_point = 5;
     */
    aim_point: string;
    /**
     * @generated from protobuf field: int32 aim_slot = 6;
     */
    aim_slot: number;
    /**
     * @generated from protobuf field: int32 step = 7;
     */
    step: number;
    /**
     * @generated from protobuf field: string arm_posture = 8;
     */
    arm_posture: string;
}
/**
 * @generated from protobuf message rosc.DebugWaferResponse
 */
export interface DebugWaferResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 step = 4;
     */
    step: number;
    /**
     * @generated from protobuf field: int32 all_step = 5;
     */
    all_step: number;
}
/**
 * @generated from protobuf message rosc.SlaveStateRequest
 */
export interface SlaveStateRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.SlaveStateResponse
 */
export interface SlaveStateResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated double torque = 3;
     */
    torque: number[];
    /**
     * @generated from protobuf field: repeated double velocity = 4;
     */
    velocity: number[];
    /**
     * @generated from protobuf field: repeated string error_code = 5;
     */
    error_code: string[];
}
/**
 * @generated from protobuf message rosc.LoadPort
 */
export interface LoadPort {
    /**
     * @generated from protobuf field: double x = 1;
     */
    x: number;
    /**
     * @generated from protobuf field: double y = 2;
     */
    y: number;
    /**
     * @generated from protobuf field: double angle = 3;
     */
    angle: number;
    /**
     * @generated from protobuf field: string type = 4;
     */
    type: string;
}
/**
 * @generated from protobuf message rosc.StartLayoutSimulationRequest
 */
export interface StartLayoutSimulationRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated rosc.LoadPort pos_list = 3;
     */
    pos_list: LoadPort[];
}
/**
 * @generated from protobuf message rosc.StartLayoutSimulationResponse
 */
export interface StartLayoutSimulationResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: bool access = 3;
     */
    access: boolean;
}
/**
 * @generated from protobuf message rosc.GetLayoutRobotPositionRequest
 */
export interface GetLayoutRobotPositionRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetLayoutRobotPositionResponse
 */
export interface GetLayoutRobotPositionResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: repeated double position = 3;
     */
    position: number[];
}
/**
 * @generated from protobuf message rosc.StopGetLayoutRobotPositionRequest
 */
export interface StopGetLayoutRobotPositionRequest {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.StopGetLayoutRobotPositionResponse
 */
export interface StopGetLayoutRobotPositionResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.SingleAxisZeroCalibrateRequest
 */
export interface SingleAxisZeroCalibrateRequest {
    /**
     * @generated from protobuf field: int32 axis = 1;
     */
    axis: number;
}
/**
 * @generated from protobuf message rosc.SingleAxisZeroCalibrateResponse
 */
export interface SingleAxisZeroCalibrateResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.SpeedConfig
 */
export interface SpeedConfig {
    /**
     * @generated from protobuf field: string attribute = 1;
     */
    attribute: string;
    /**
     * @generated from protobuf field: double value = 2;
     */
    value: number;
}
/**
 * @generated from protobuf message rosc.GetSpeedConfigRequest
 */
export interface GetSpeedConfigRequest {
    /**
     * @generated from protobuf field: string speed_type = 1;
     */
    speed_type: string;
    /**
     * @generated from protobuf field: string speed_level = 2;
     */
    speed_level: string;
    /**
     * @generated from protobuf field: string joint = 3;
     */
    joint: string;
}
/**
 * @generated from protobuf message rosc.GetSpeedConfigResponse
 */
export interface GetSpeedConfigResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string speed_config = 3;
     */
    speed_config: string;
    /**
     * @generated from protobuf field: bool specify_speed = 4;
     */
    specify_speed: boolean;
}
/**
 * @generated from protobuf message rosc.SaveSpeedConfigRequest
 */
export interface SaveSpeedConfigRequest {
    /**
     * @generated from protobuf field: repeated rosc.SpeedConfig data = 1;
     */
    data: SpeedConfig[];
    /**
     * @generated from protobuf field: string speed_type = 2;
     */
    speed_type: string;
    /**
     * @generated from protobuf field: bool specify_speed = 3;
     */
    specify_speed: boolean;
}
/**
 * @generated from protobuf message rosc.SaveSpeedConfigResponse
 */
export interface SaveSpeedConfigResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetSorterConfigRequest
 */
export interface GetSorterConfigRequest {
    /**
     * @generated from protobuf field: string offset_type = 1;
     */
    offset_type: string;
    /**
     * @generated from protobuf field: int32 number = 2;
     */
    number: number;
}
/**
 * @generated from protobuf message rosc.GetSorterConfigResponse
 */
export interface GetSorterConfigResponse {
    /**
     * @generated from protobuf field: string reply = 1;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
    /**
     * @generated from protobuf field: string sorter_config = 3;
     */
    sorter_config: string;
}
/**
 * @generated from protobuf message rosc.SorterConfig
 */
export interface SorterConfig {
    /**
     * @generated from protobuf field: string attribute = 1;
     */
    attribute: string;
    /**
     * @generated from protobuf field: double value = 2;
     */
    value: number;
}
/**
 * @generated from protobuf message rosc.SaveSorterConfigRequest
 */
export interface SaveSorterConfigRequest {
    /**
     * @generated from protobuf field: string offset_type = 1;
     */
    offset_type: string;
    /**
     * @generated from protobuf field: int32 number = 2;
     */
    number: number;
    /**
     * @generated from protobuf field: repeated rosc.SorterConfig sorter_config = 3;
     */
    sorter_config: SorterConfig[];
}
/**
 * @generated from protobuf message rosc.SaveSorterConfigResponse
 */
export interface SaveSorterConfigResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: string reply = 2;
     */
    reply: string;
}
/**
 * @generated from protobuf message rosc.SearchMappingRequest
 */
export interface SearchMappingRequest {
    /**
     * @generated from protobuf field: string cassette = 1;
     */
    cassette: string;
}
/**
 * @generated from protobuf message rosc.SearchMappingResponse
 */
export interface SearchMappingResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: string reply = 2;
     */
    reply: string;
    /**
     * @generated from protobuf field: int32 num = 3;
     */
    num: number;
    /**
     * @generated from protobuf field: repeated int32 wafer_condition = 4;
     */
    wafer_condition: number[];
    /**
     * @generated from protobuf field: double start_position = 5;
     */
    start_position: number;
    /**
     * @generated from protobuf field: double finish_position = 6;
     */
    finish_position: number;
    /**
     * @generated from protobuf field: repeated double wafer_thick = 7;
     */
    wafer_thick: number[];
}
/**
 * @generated from protobuf message rosc.MappingCalibrateRequest
 */
export interface MappingCalibrateRequest {
    /**
     * @generated from protobuf field: string cassette = 1;
     */
    cassette: string;
}
/**
 * @generated from protobuf message rosc.MappingCalibrateResponse
 */
export interface MappingCalibrateResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: string reply = 2;
     */
    reply: string;
}
/**
 * @generated from protobuf message rosc.MappingSettingItem
 */
export interface MappingSettingItem {
    /**
     * @generated from protobuf field: string mapping_name = 1;
     */
    mapping_name: string;
    /**
     * @generated from protobuf field: double mapping_values = 2;
     */
    mapping_values: number;
}
/**
 * @generated from protobuf message rosc.MappingSettingRequest
 */
export interface MappingSettingRequest {
    /**
     * @generated from protobuf field: string station = 1;
     */
    station: string;
}
/**
 * @generated from protobuf message rosc.MappingSettingResponse
 */
export interface MappingSettingResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: string reply = 2;
     */
    reply: string;
    /**
     * @generated from protobuf field: repeated string mapping_name = 3;
     */
    mapping_name: string[];
    /**
     * @generated from protobuf field: repeated double mapping_value = 4;
     */
    mapping_value: number[];
}
/**
 * @generated from protobuf message rosc.SaveMappingSettingRequest
 */
export interface SaveMappingSettingRequest {
    /**
     * @generated from protobuf field: string station = 1;
     */
    station: string;
    /**
     * @generated from protobuf field: repeated rosc.MappingSettingItem mapping_setting = 2;
     */
    mapping_setting: MappingSettingItem[];
}
/**
 * @generated from protobuf message rosc.SaveMappingSettingResponse
 */
export interface SaveMappingSettingResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: string reply = 2;
     */
    reply: string;
}
/**
 * @generated from protobuf message rosc.SetSolenoidRequest
 */
export interface SetSolenoidRequest {
    /**
     * @generated from protobuf field: int32 arm = 1;
     */
    arm: number;
    /**
     * @generated from protobuf field: int32 value = 2;
     */
    value: number;
}
/**
 * @generated from protobuf message rosc.SetSolenoidResponse
 */
export interface SetSolenoidResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: string reply = 2;
     */
    reply: string;
}
/**
 * @generated from protobuf message rosc.GetSolenoidRequest
 */
export interface GetSolenoidRequest {
}
/**
 * @generated from protobuf message rosc.GetSolenoidResponse
 */
export interface GetSolenoidResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: int32 solenoid_r1 = 2;
     */
    solenoid_r1: number;
    /**
     * @generated from protobuf field: int32 solenoid_r2 = 3;
     */
    solenoid_r2: number;
}
/**
 * @generated from protobuf message rosc.GetEnableMappingRequest
 */
export interface GetEnableMappingRequest {
}
/**
 * @generated from protobuf message rosc.GetEnableMappingResponse
 */
export interface GetEnableMappingResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: int32 enable = 2;
     */
    enable: number;
}
/**
 * @generated from protobuf message rosc.SaveEnableMappingRequest
 */
export interface SaveEnableMappingRequest {
    /**
     * @generated from protobuf field: int32 enable = 1;
     */
    enable: number;
}
/**
 * @generated from protobuf message rosc.SaveEnableMappingResponse
 */
export interface SaveEnableMappingResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.RedifyControllerIPRequest
 */
export interface RedifyControllerIPRequest {
    /**
     * @generated from protobuf field: string addresses = 1;
     */
    addresses: string;
    /**
     * @generated from protobuf field: string gateway4 = 2;
     */
    gateway4: string;
}
/**
 * @generated from protobuf message rosc.RedifyControllerIPResponse
 */
export interface RedifyControllerIPResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetServoEncodeRequest
 */
export interface GetServoEncodeRequest {
}
/**
 * @generated from protobuf message rosc.GetServoEncodeResponse
 */
export interface GetServoEncodeResponse {
    /**
     * @generated from protobuf field: repeated int32 encode = 1;
     */
    encode: number[];
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.UpdatePointFileRequest
 */
export interface UpdatePointFileRequest {
    /**
     * bytes data = 1;
     *
     * @generated from protobuf field: string data = 1;
     */
    data: string;
}
/**
 * @generated from protobuf message rosc.UpdatePointFileResponse
 */
export interface UpdatePointFileResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetAWCConfigRequest
 */
export interface GetAWCConfigRequest {
    /**
     * @generated from protobuf field: int32 stage = 1;
     */
    stage: number;
}
/**
 * @generated from protobuf message rosc.GetAWCConfigResponse
 */
export interface GetAWCConfigResponse {
    /**
     * @generated from protobuf field: bool enable_awc = 1;
     */
    enable_awc: boolean;
    /**
     * @generated from protobuf field: int32 sensor_num = 2;
     */
    sensor_num: number;
    /**
     * @generated from protobuf field: int32 sensor_io_serial1 = 3;
     */
    sensor_io_serial1: number;
    /**
     * @generated from protobuf field: int32 sensor_io_serial2 = 4;
     */
    sensor_io_serial2: number;
    /**
     * @generated from protobuf field: string sensor_pos1 = 5;
     */
    sensor_pos1: string;
    /**
     * @generated from protobuf field: string sensor_pos2 = 6;
     */
    sensor_pos2: string;
    /**
     * @generated from protobuf field: int32 code = 7;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.SaveAWCConfigRequest
 */
export interface SaveAWCConfigRequest {
    /**
     * @generated from protobuf field: int32 stage = 1;
     */
    stage: number;
    /**
     * @generated from protobuf field: bool enable_awc = 2;
     */
    enable_awc: boolean;
    /**
     * @generated from protobuf field: int32 sensor_num = 3;
     */
    sensor_num: number;
    /**
     * @generated from protobuf field: int32 sensor_io_serial1 = 4;
     */
    sensor_io_serial1: number;
    /**
     * @generated from protobuf field: int32 sensor_io_serial2 = 5;
     */
    sensor_io_serial2: number;
    /**
     * @generated from protobuf field: string sensor_pos1 = 6;
     */
    sensor_pos1: string;
    /**
     * @generated from protobuf field: string sensor_pos2 = 7;
     */
    sensor_pos2: string;
}
/**
 * @generated from protobuf message rosc.SaveAWCConfigResponse
 */
export interface SaveAWCConfigResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.CalibrateAWCSensorRequest
 */
export interface CalibrateAWCSensorRequest {
    /**
     * @generated from protobuf field: int32 stage = 1;
     */
    stage: number;
    /**
     * @generated from protobuf field: int32 arm = 2;
     */
    arm: number;
}
/**
 * @generated from protobuf message rosc.CalibrateAWCSensorResponse
 */
export interface CalibrateAWCSensorResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.GetIOInterlockSettingRequest
 */
export interface GetIOInterlockSettingRequest {
    /**
     * @generated from protobuf field: int32 stage = 1;
     */
    stage: number;
}
/**
 * @generated from protobuf message rosc.GetIOInterlockSettingResponse
 */
export interface GetIOInterlockSettingResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
    /**
     * @generated from protobuf field: int32 enable_extend_sensor = 2;
     */
    enable_extend_sensor: number;
    /**
     * @generated from protobuf field: int32 wafer_sensor = 3;
     */
    wafer_sensor: number;
    /**
     * @generated from protobuf field: int32 arm_at_home_sensor = 4;
     */
    arm_at_home_sensor: number;
    /**
     * @generated from protobuf field: string enable_extend_state = 5;
     */
    enable_extend_state: string;
    /**
     * @generated from protobuf field: string arm_at_home_state = 6;
     */
    arm_at_home_state: string;
    /**
     * @generated from protobuf field: string wafer_sensor_state = 7;
     */
    wafer_sensor_state: string;
    /**
     * @generated from protobuf field: string tz_state = 8;
     */
    tz_state: string;
}
/**
 * @generated from protobuf message rosc.SaveIOInterlockSettingRequest
 */
export interface SaveIOInterlockSettingRequest {
    /**
     * @generated from protobuf field: int32 stage = 1;
     */
    stage: number;
    /**
     * @generated from protobuf field: int32 enable_extend_sensor = 2;
     */
    enable_extend_sensor: number;
    /**
     * @generated from protobuf field: int32 wafer_sensor = 3;
     */
    wafer_sensor: number;
    /**
     * @generated from protobuf field: int32 arm_at_home_sensor = 4;
     */
    arm_at_home_sensor: number;
    /**
     * @generated from protobuf field: string enable_extend_state = 5;
     */
    enable_extend_state: string;
    /**
     * @generated from protobuf field: string arm_at_home_state = 6;
     */
    arm_at_home_state: string;
    /**
     * @generated from protobuf field: string wafer_sensor_state = 7;
     */
    wafer_sensor_state: string;
    /**
     * @generated from protobuf field: string tz_state = 8;
     */
    tz_state: string;
}
/**
 * @generated from protobuf message rosc.SaveIOInterlockSettingResponse
 */
export interface SaveIOInterlockSettingResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.CalibrateWaferSensorRequest
 */
export interface CalibrateWaferSensorRequest {
    /**
     * @generated from protobuf field: int32 stage = 1;
     */
    stage: number;
}
/**
 * @generated from protobuf message rosc.CalibrateWaferSensorResponse
 */
export interface CalibrateWaferSensorResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.FindZeroRequest
 */
export interface FindZeroRequest {
}
/**
 * @generated from protobuf message rosc.FindZeroResponse
 */
export interface FindZeroResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.StageSettingItem
 */
export interface StageSettingItem {
    /**
     * @generated from protobuf field: string attribute = 1;
     */
    attribute: string;
    /**
     * @generated from protobuf field: double value = 2;
     */
    value: number;
}
/**
 * @generated from protobuf message rosc.GetStageSettingRequest
 */
export interface GetStageSettingRequest {
    /**
     * @generated from protobuf field: int32 stage = 1;
     */
    stage: number;
}
/**
 * @generated from protobuf message rosc.GetStageSettingResponse
 */
export interface GetStageSettingResponse {
    /**
     * @generated from protobuf field: repeated rosc.StageSettingItem setting_items = 1;
     */
    setting_items: StageSettingItem[];
    /**
     * @generated from protobuf field: int32 code = 2;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.SaveStageSettingRequest
 */
export interface SaveStageSettingRequest {
    /**
     * @generated from protobuf field: int32 stage = 1;
     */
    stage: number;
    /**
     * @generated from protobuf field: repeated rosc.StageSettingItem setting_items = 2;
     */
    setting_items: StageSettingItem[];
}
/**
 * @generated from protobuf message rosc.SaveStageSettingResponse
 */
export interface SaveStageSettingResponse {
    /**
     * @generated from protobuf field: int32 code = 1;
     */
    code: number;
}
/**
 * @generated from protobuf message rosc.SetRunningModeRequest
 */
export interface SetRunningModeRequest {
    /**
     * @generated from protobuf field: string mode = 1;
     */
    mode: string;
}
/**
 * @generated from protobuf message rosc.SetRunningModeResponse
 */
export interface SetRunningModeResponse {
}
/**
 * @generated from protobuf message rosc.CalibrateRobotParamRequest
 */
export interface CalibrateRobotParamRequest {
}
/**
 * @generated from protobuf message rosc.CalibrateRobotParamResponse
 */
export interface CalibrateRobotParamResponse {
    /**
     * @generated from protobuf field: int32 result = 1;
     */
    result: number;
    /**
     * @generated from protobuf field: string message = 2;
     */
    message: string;
    /**
     * @generated from protobuf field: int32 code = 3;
     */
    code: number;
}
/**
 * @generated from protobuf enum rosc.GRPCAxisNum
 */
export enum GRPCAxisNum {
    /**
     * @generated from protobuf enum value: ELEVATION = 0;
     */
    ELEVATION = 0,
    /**
     * @generated from protobuf enum value: ROTATION = 1;
     */
    ROTATION = 1,
    /**
     * @generated from protobuf enum value: EXTENSION_L = 2;
     */
    EXTENSION_L = 2,
    /**
     * @generated from protobuf enum value: EXTENSION_R = 3;
     */
    EXTENSION_R = 3,
    /**
     * @generated from protobuf enum value: EXTENSION = 4;
     */
    EXTENSION = 4,
    /**
     * @generated from protobuf enum value: WRIST_L = 5;
     */
    WRIST_L = 5,
    /**
     * @generated from protobuf enum value: WRIST_R = 6;
     */
    WRIST_R = 6,
    /**
     * @generated from protobuf enum value: CARTESIAN_X_L = 7;
     */
    CARTESIAN_X_L = 7,
    /**
     * @generated from protobuf enum value: CARTESIAN_X_R = 8;
     */
    CARTESIAN_X_R = 8,
    /**
     * @generated from protobuf enum value: CARTESIAN_Y_L = 9;
     */
    CARTESIAN_Y_L = 9,
    /**
     * @generated from protobuf enum value: CARTESIAN_Y_R = 10;
     */
    CARTESIAN_Y_R = 10,
    /**
     * @generated from protobuf enum value: FLIP_L = 11;
     */
    FLIP_L = 11,
    /**
     * @generated from protobuf enum value: FLIP_R = 12;
     */
    FLIP_R = 12
}
/**
 * @generated from protobuf enum rosc.JogVelocityLevel
 */
export enum JogVelocityLevel {
    /**
     * 高速
     *
     * @generated from protobuf enum value: HIGH = 0;
     */
    HIGH = 0,
    /**
     * 中速
     *
     * @generated from protobuf enum value: MEDIUM = 1;
     */
    MEDIUM = 1,
    /**
     * 低速
     *
     * @generated from protobuf enum value: LOW = 2;
     */
    LOW = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class PingResponse$Type extends MessageType<PingResponse> {
    constructor() {
        super("rosc.PingResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PingResponse>): PingResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PingResponse): PingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.PingResponse
 */
export const PingResponse = new PingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PowerOnResponse$Type extends MessageType<PowerOnResponse> {
    constructor() {
        super("rosc.PowerOnResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PowerOnResponse>): PowerOnResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PowerOnResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PowerOnResponse): PowerOnResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PowerOnResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.PowerOnResponse
 */
export const PowerOnResponse = new PowerOnResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PowerOffResponse$Type extends MessageType<PowerOffResponse> {
    constructor() {
        super("rosc.PowerOffResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PowerOffResponse>): PowerOffResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PowerOffResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PowerOffResponse): PowerOffResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PowerOffResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.PowerOffResponse
 */
export const PowerOffResponse = new PowerOffResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClearErrorResponse$Type extends MessageType<ClearErrorResponse> {
    constructor() {
        super("rosc.ClearErrorResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ClearErrorResponse>): ClearErrorResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ClearErrorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClearErrorResponse): ClearErrorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClearErrorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.ClearErrorResponse
 */
export const ClearErrorResponse = new ClearErrorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmergencyStopRequest$Type extends MessageType<EmergencyStopRequest> {
    constructor() {
        super("rosc.EmergencyStopRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EmergencyStopRequest>): EmergencyStopRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EmergencyStopRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmergencyStopRequest): EmergencyStopRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmergencyStopRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.EmergencyStopRequest
 */
export const EmergencyStopRequest = new EmergencyStopRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmergencyStopResponse$Type extends MessageType<EmergencyStopResponse> {
    constructor() {
        super("rosc.EmergencyStopResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EmergencyStopResponse>): EmergencyStopResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EmergencyStopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmergencyStopResponse): EmergencyStopResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmergencyStopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.EmergencyStopResponse
 */
export const EmergencyStopResponse = new EmergencyStopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmergencyRecoverRequest$Type extends MessageType<EmergencyRecoverRequest> {
    constructor() {
        super("rosc.EmergencyRecoverRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EmergencyRecoverRequest>): EmergencyRecoverRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EmergencyRecoverRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmergencyRecoverRequest): EmergencyRecoverRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmergencyRecoverRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.EmergencyRecoverRequest
 */
export const EmergencyRecoverRequest = new EmergencyRecoverRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EmergencyRecoverResponse$Type extends MessageType<EmergencyRecoverResponse> {
    constructor() {
        super("rosc.EmergencyRecoverResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EmergencyRecoverResponse>): EmergencyRecoverResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EmergencyRecoverResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EmergencyRecoverResponse): EmergencyRecoverResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EmergencyRecoverResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.EmergencyRecoverResponse
 */
export const EmergencyRecoverResponse = new EmergencyRecoverResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachMoveStepRequest$Type extends MessageType<TeachMoveStepRequest> {
    constructor() {
        super("rosc.TeachMoveStepRequest", [
            { no: 1, name: "axis", kind: "enum", T: () => ["rosc.GRPCAxisNum", GRPCAxisNum] },
            { no: 2, name: "direction", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "jog_step", kind: "scalar", localName: "jog_step", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<TeachMoveStepRequest>): TeachMoveStepRequest {
        const message = { axis: 0, direction: 0, jog_step: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachMoveStepRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachMoveStepRequest): TeachMoveStepRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* rosc.GRPCAxisNum axis */ 1:
                    message.axis = reader.int32();
                    break;
                case /* int32 direction */ 2:
                    message.direction = reader.int32();
                    break;
                case /* double jog_step */ 3:
                    message.jog_step = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachMoveStepRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* rosc.GRPCAxisNum axis = 1; */
        if (message.axis !== 0)
            writer.tag(1, WireType.Varint).int32(message.axis);
        /* int32 direction = 2; */
        if (message.direction !== 0)
            writer.tag(2, WireType.Varint).int32(message.direction);
        /* double jog_step = 3; */
        if (message.jog_step !== 0)
            writer.tag(3, WireType.Bit64).double(message.jog_step);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachMoveStepRequest
 */
export const TeachMoveStepRequest = new TeachMoveStepRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachMoveStepResponse$Type extends MessageType<TeachMoveStepResponse> {
    constructor() {
        super("rosc.TeachMoveStepResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachMoveStepResponse>): TeachMoveStepResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachMoveStepResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachMoveStepResponse): TeachMoveStepResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachMoveStepResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachMoveStepResponse
 */
export const TeachMoveStepResponse = new TeachMoveStepResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachJogStartRequest$Type extends MessageType<TeachJogStartRequest> {
    constructor() {
        super("rosc.TeachJogStartRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "axis", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "direction", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "jog_step", kind: "scalar", localName: "jog_step", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "velocity_level", kind: "enum", localName: "velocity_level", opt: true, T: () => ["rosc.JogVelocityLevel", JogVelocityLevel] }
        ]);
    }
    create(value?: PartialMessage<TeachJogStartRequest>): TeachJogStartRequest {
        const message = { message: "", code: 0, axis: 0, direction: 0, jog_step: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachJogStartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachJogStartRequest): TeachJogStartRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* int32 axis */ 3:
                    message.axis = reader.int32();
                    break;
                case /* int32 direction */ 4:
                    message.direction = reader.int32();
                    break;
                case /* double jog_step */ 5:
                    message.jog_step = reader.double();
                    break;
                case /* optional rosc.JogVelocityLevel velocity_level */ 6:
                    message.velocity_level = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachJogStartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* int32 axis = 3; */
        if (message.axis !== 0)
            writer.tag(3, WireType.Varint).int32(message.axis);
        /* int32 direction = 4; */
        if (message.direction !== 0)
            writer.tag(4, WireType.Varint).int32(message.direction);
        /* double jog_step = 5; */
        if (message.jog_step !== 0)
            writer.tag(5, WireType.Bit64).double(message.jog_step);
        /* optional rosc.JogVelocityLevel velocity_level = 6; */
        if (message.velocity_level !== undefined)
            writer.tag(6, WireType.Varint).int32(message.velocity_level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachJogStartRequest
 */
export const TeachJogStartRequest = new TeachJogStartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachJogStartResponse$Type extends MessageType<TeachJogStartResponse> {
    constructor() {
        super("rosc.TeachJogStartResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachJogStartResponse>): TeachJogStartResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachJogStartResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachJogStartResponse): TeachJogStartResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachJogStartResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachJogStartResponse
 */
export const TeachJogStartResponse = new TeachJogStartResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachJogStopRequest$Type extends MessageType<TeachJogStopRequest> {
    constructor() {
        super("rosc.TeachJogStopRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachJogStopRequest>): TeachJogStopRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachJogStopRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachJogStopRequest): TeachJogStopRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachJogStopRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachJogStopRequest
 */
export const TeachJogStopRequest = new TeachJogStopRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachJogStopResponse$Type extends MessageType<TeachJogStopResponse> {
    constructor() {
        super("rosc.TeachJogStopResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachJogStopResponse>): TeachJogStopResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachJogStopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachJogStopResponse): TeachJogStopResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachJogStopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachJogStopResponse
 */
export const TeachJogStopResponse = new TeachJogStopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachStreamStartGetJointsResponse$Type extends MessageType<TeachStreamStartGetJointsResponse> {
    constructor() {
        super("rosc.TeachStreamStartGetJointsResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "joints", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "servo_state", kind: "scalar", localName: "servo_state", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "left_arm", kind: "scalar", localName: "left_arm", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "right_arm", kind: "scalar", localName: "right_arm", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "velocitys", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "a", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 9, name: "b", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "c", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 11, name: "d", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<TeachStreamStartGetJointsResponse>): TeachStreamStartGetJointsResponse {
        const message = { reply: "", code: 0, joints: [], servo_state: "", left_arm: [], right_arm: [], velocitys: [], a: [], b: [], c: [], d: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachStreamStartGetJointsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachStreamStartGetJointsResponse): TeachStreamStartGetJointsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* repeated double joints */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.joints.push(reader.double());
                    else
                        message.joints.push(reader.double());
                    break;
                case /* string servo_state */ 4:
                    message.servo_state = reader.string();
                    break;
                case /* repeated double left_arm */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.left_arm.push(reader.double());
                    else
                        message.left_arm.push(reader.double());
                    break;
                case /* repeated double right_arm */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.right_arm.push(reader.double());
                    else
                        message.right_arm.push(reader.double());
                    break;
                case /* repeated double velocitys */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.velocitys.push(reader.double());
                    else
                        message.velocitys.push(reader.double());
                    break;
                case /* repeated double a */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.a.push(reader.double());
                    else
                        message.a.push(reader.double());
                    break;
                case /* repeated double b */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.b.push(reader.double());
                    else
                        message.b.push(reader.double());
                    break;
                case /* repeated double c */ 10:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.c.push(reader.double());
                    else
                        message.c.push(reader.double());
                    break;
                case /* repeated double d */ 11:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.d.push(reader.double());
                    else
                        message.d.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachStreamStartGetJointsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* repeated double joints = 3; */
        if (message.joints.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.joints.length; i++)
                writer.double(message.joints[i]);
            writer.join();
        }
        /* string servo_state = 4; */
        if (message.servo_state !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.servo_state);
        /* repeated double left_arm = 5; */
        if (message.left_arm.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.left_arm.length; i++)
                writer.double(message.left_arm[i]);
            writer.join();
        }
        /* repeated double right_arm = 6; */
        if (message.right_arm.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.right_arm.length; i++)
                writer.double(message.right_arm[i]);
            writer.join();
        }
        /* repeated double velocitys = 7; */
        if (message.velocitys.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.velocitys.length; i++)
                writer.double(message.velocitys[i]);
            writer.join();
        }
        /* repeated double a = 8; */
        if (message.a.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.a.length; i++)
                writer.double(message.a[i]);
            writer.join();
        }
        /* repeated double b = 9; */
        if (message.b.length) {
            writer.tag(9, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.b.length; i++)
                writer.double(message.b[i]);
            writer.join();
        }
        /* repeated double c = 10; */
        if (message.c.length) {
            writer.tag(10, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.c.length; i++)
                writer.double(message.c[i]);
            writer.join();
        }
        /* repeated double d = 11; */
        if (message.d.length) {
            writer.tag(11, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.d.length; i++)
                writer.double(message.d[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachStreamStartGetJointsResponse
 */
export const TeachStreamStartGetJointsResponse = new TeachStreamStartGetJointsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachStreamStopGetJointsResponse$Type extends MessageType<TeachStreamStopGetJointsResponse> {
    constructor() {
        super("rosc.TeachStreamStopGetJointsResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachStreamStopGetJointsResponse>): TeachStreamStopGetJointsResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachStreamStopGetJointsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachStreamStopGetJointsResponse): TeachStreamStopGetJointsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachStreamStopGetJointsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachStreamStopGetJointsResponse
 */
export const TeachStreamStopGetJointsResponse = new TeachStreamStopGetJointsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachBoardStartStatusStreamResponse$Type extends MessageType<TeachBoardStartStatusStreamResponse> {
    constructor() {
        super("rosc.TeachBoardStartStatusStreamResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "joints", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "servo_state", kind: "scalar", localName: "servo_state", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "left_arm", kind: "scalar", localName: "left_arm", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "right_arm", kind: "scalar", localName: "right_arm", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "velocitys", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "digit_io_out_r1", kind: "scalar", localName: "digit_io_out_r1", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "digit_io_out_r2", kind: "scalar", localName: "digit_io_out_r2", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "digit_io_in_r1", kind: "scalar", localName: "digit_io_in_r1", T: 8 /*ScalarType.BOOL*/ },
            { no: 11, name: "digit_io_in_r2", kind: "scalar", localName: "digit_io_in_r2", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TeachBoardStartStatusStreamResponse>): TeachBoardStartStatusStreamResponse {
        const message = { reply: "", code: 0, joints: [], servo_state: "", left_arm: [], right_arm: [], velocitys: [], digit_io_out_r1: false, digit_io_out_r2: false, digit_io_in_r1: false, digit_io_in_r2: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachBoardStartStatusStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachBoardStartStatusStreamResponse): TeachBoardStartStatusStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* repeated double joints */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.joints.push(reader.double());
                    else
                        message.joints.push(reader.double());
                    break;
                case /* string servo_state */ 4:
                    message.servo_state = reader.string();
                    break;
                case /* repeated double left_arm */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.left_arm.push(reader.double());
                    else
                        message.left_arm.push(reader.double());
                    break;
                case /* repeated double right_arm */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.right_arm.push(reader.double());
                    else
                        message.right_arm.push(reader.double());
                    break;
                case /* repeated double velocitys */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.velocitys.push(reader.double());
                    else
                        message.velocitys.push(reader.double());
                    break;
                case /* bool digit_io_out_r1 */ 8:
                    message.digit_io_out_r1 = reader.bool();
                    break;
                case /* bool digit_io_out_r2 */ 9:
                    message.digit_io_out_r2 = reader.bool();
                    break;
                case /* bool digit_io_in_r1 */ 10:
                    message.digit_io_in_r1 = reader.bool();
                    break;
                case /* bool digit_io_in_r2 */ 11:
                    message.digit_io_in_r2 = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachBoardStartStatusStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* repeated double joints = 3; */
        if (message.joints.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.joints.length; i++)
                writer.double(message.joints[i]);
            writer.join();
        }
        /* string servo_state = 4; */
        if (message.servo_state !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.servo_state);
        /* repeated double left_arm = 5; */
        if (message.left_arm.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.left_arm.length; i++)
                writer.double(message.left_arm[i]);
            writer.join();
        }
        /* repeated double right_arm = 6; */
        if (message.right_arm.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.right_arm.length; i++)
                writer.double(message.right_arm[i]);
            writer.join();
        }
        /* repeated double velocitys = 7; */
        if (message.velocitys.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.velocitys.length; i++)
                writer.double(message.velocitys[i]);
            writer.join();
        }
        /* bool digit_io_out_r1 = 8; */
        if (message.digit_io_out_r1 !== false)
            writer.tag(8, WireType.Varint).bool(message.digit_io_out_r1);
        /* bool digit_io_out_r2 = 9; */
        if (message.digit_io_out_r2 !== false)
            writer.tag(9, WireType.Varint).bool(message.digit_io_out_r2);
        /* bool digit_io_in_r1 = 10; */
        if (message.digit_io_in_r1 !== false)
            writer.tag(10, WireType.Varint).bool(message.digit_io_in_r1);
        /* bool digit_io_in_r2 = 11; */
        if (message.digit_io_in_r2 !== false)
            writer.tag(11, WireType.Varint).bool(message.digit_io_in_r2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachBoardStartStatusStreamResponse
 */
export const TeachBoardStartStatusStreamResponse = new TeachBoardStartStatusStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachBoardStopStatusStreamResponse$Type extends MessageType<TeachBoardStopStatusStreamResponse> {
    constructor() {
        super("rosc.TeachBoardStopStatusStreamResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachBoardStopStatusStreamResponse>): TeachBoardStopStatusStreamResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachBoardStopStatusStreamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachBoardStopStatusStreamResponse): TeachBoardStopStatusStreamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachBoardStopStatusStreamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachBoardStopStatusStreamResponse
 */
export const TeachBoardStopStatusStreamResponse = new TeachBoardStopStatusStreamResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachSavePositionRequest$Type extends MessageType<TeachSavePositionRequest> {
    constructor() {
        super("rosc.TeachSavePositionRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "describe", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "arm", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "slot", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "has_mid", kind: "scalar", localName: "has_mid", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachSavePositionRequest>): TeachSavePositionRequest {
        const message = { message: "", code: 0, name: "", describe: "", arm: "", slot: 0, has_mid: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachSavePositionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachSavePositionRequest): TeachSavePositionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string describe */ 4:
                    message.describe = reader.string();
                    break;
                case /* string arm */ 5:
                    message.arm = reader.string();
                    break;
                case /* int32 slot */ 6:
                    message.slot = reader.int32();
                    break;
                case /* int32 has_mid */ 7:
                    message.has_mid = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachSavePositionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string describe = 4; */
        if (message.describe !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.describe);
        /* string arm = 5; */
        if (message.arm !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.arm);
        /* int32 slot = 6; */
        if (message.slot !== 0)
            writer.tag(6, WireType.Varint).int32(message.slot);
        /* int32 has_mid = 7; */
        if (message.has_mid !== 0)
            writer.tag(7, WireType.Varint).int32(message.has_mid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachSavePositionRequest
 */
export const TeachSavePositionRequest = new TeachSavePositionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachSavePositionResponse$Type extends MessageType<TeachSavePositionResponse> {
    constructor() {
        super("rosc.TeachSavePositionResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "joints", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<TeachSavePositionResponse>): TeachSavePositionResponse {
        const message = { reply: "", code: 0, joints: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachSavePositionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachSavePositionResponse): TeachSavePositionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* repeated double joints */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.joints.push(reader.double());
                    else
                        message.joints.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachSavePositionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* repeated double joints = 3; */
        if (message.joints.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.joints.length; i++)
                writer.double(message.joints[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachSavePositionResponse
 */
export const TeachSavePositionResponse = new TeachSavePositionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachSetVelocityRequest$Type extends MessageType<TeachSetVelocityRequest> {
    constructor() {
        super("rosc.TeachSetVelocityRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "velocity", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachSetVelocityRequest>): TeachSetVelocityRequest {
        const message = { message: "", code: 0, velocity: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachSetVelocityRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachSetVelocityRequest): TeachSetVelocityRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* int32 velocity */ 3:
                    message.velocity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachSetVelocityRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* int32 velocity = 3; */
        if (message.velocity !== 0)
            writer.tag(3, WireType.Varint).int32(message.velocity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachSetVelocityRequest
 */
export const TeachSetVelocityRequest = new TeachSetVelocityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachSetVelocityResponse$Type extends MessageType<TeachSetVelocityResponse> {
    constructor() {
        super("rosc.TeachSetVelocityResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachSetVelocityResponse>): TeachSetVelocityResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachSetVelocityResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachSetVelocityResponse): TeachSetVelocityResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachSetVelocityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachSetVelocityResponse
 */
export const TeachSetVelocityResponse = new TeachSetVelocityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachGetVelocityRequest$Type extends MessageType<TeachGetVelocityRequest> {
    constructor() {
        super("rosc.TeachGetVelocityRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachGetVelocityRequest>): TeachGetVelocityRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachGetVelocityRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachGetVelocityRequest): TeachGetVelocityRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachGetVelocityRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachGetVelocityRequest
 */
export const TeachGetVelocityRequest = new TeachGetVelocityRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachGetVelocityResponse$Type extends MessageType<TeachGetVelocityResponse> {
    constructor() {
        super("rosc.TeachGetVelocityResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "velocity", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachGetVelocityResponse>): TeachGetVelocityResponse {
        const message = { reply: "", code: 0, velocity: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachGetVelocityResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachGetVelocityResponse): TeachGetVelocityResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* int32 velocity */ 3:
                    message.velocity = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachGetVelocityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* int32 velocity = 3; */
        if (message.velocity !== 0)
            writer.tag(3, WireType.Varint).int32(message.velocity);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachGetVelocityResponse
 */
export const TeachGetVelocityResponse = new TeachGetVelocityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetJogVelocityLevelRequest$Type extends MessageType<SetJogVelocityLevelRequest> {
    constructor() {
        super("rosc.SetJogVelocityLevelRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "velocity_level", kind: "enum", localName: "velocity_level", T: () => ["rosc.JogVelocityLevel", JogVelocityLevel] }
        ]);
    }
    create(value?: PartialMessage<SetJogVelocityLevelRequest>): SetJogVelocityLevelRequest {
        const message = { message: "", code: 0, velocity_level: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetJogVelocityLevelRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetJogVelocityLevelRequest): SetJogVelocityLevelRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* rosc.JogVelocityLevel velocity_level */ 3:
                    message.velocity_level = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetJogVelocityLevelRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* rosc.JogVelocityLevel velocity_level = 3; */
        if (message.velocity_level !== 0)
            writer.tag(3, WireType.Varint).int32(message.velocity_level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SetJogVelocityLevelRequest
 */
export const SetJogVelocityLevelRequest = new SetJogVelocityLevelRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JogVelocityResponse$Type extends MessageType<JogVelocityResponse> {
    constructor() {
        super("rosc.JogVelocityResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "velocity", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "velocity_level", kind: "enum", localName: "velocity_level", T: () => ["rosc.JogVelocityLevel", JogVelocityLevel] }
        ]);
    }
    create(value?: PartialMessage<JogVelocityResponse>): JogVelocityResponse {
        const message = { reply: "", code: 0, velocity: [], velocity_level: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JogVelocityResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JogVelocityResponse): JogVelocityResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* repeated int32 velocity */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.velocity.push(reader.int32());
                    else
                        message.velocity.push(reader.int32());
                    break;
                case /* rosc.JogVelocityLevel velocity_level */ 4:
                    message.velocity_level = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JogVelocityResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* repeated int32 velocity = 3; */
        if (message.velocity.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.velocity.length; i++)
                writer.int32(message.velocity[i]);
            writer.join();
        }
        /* rosc.JogVelocityLevel velocity_level = 4; */
        if (message.velocity_level !== 0)
            writer.tag(4, WireType.Varint).int32(message.velocity_level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.JogVelocityResponse
 */
export const JogVelocityResponse = new JogVelocityResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachMoveRequest$Type extends MessageType<TeachMoveRequest> {
    constructor() {
        super("rosc.TeachMoveRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TeachMoveRequest>): TeachMoveRequest {
        const message = { message: "", code: 0, name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachMoveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachMoveRequest): TeachMoveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachMoveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachMoveRequest
 */
export const TeachMoveRequest = new TeachMoveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachMoveResponse$Type extends MessageType<TeachMoveResponse> {
    constructor() {
        super("rosc.TeachMoveResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachMoveResponse>): TeachMoveResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachMoveResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachMoveResponse): TeachMoveResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachMoveResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachMoveResponse
 */
export const TeachMoveResponse = new TeachMoveResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetIOOutputStateRequest$Type extends MessageType<SetIOOutputStateRequest> {
    constructor() {
        super("rosc.SetIOOutputStateRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "serial", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "state", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetIOOutputStateRequest>): SetIOOutputStateRequest {
        const message = { message: "", code: 0, serial: 0, state: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetIOOutputStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetIOOutputStateRequest): SetIOOutputStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* int32 serial */ 3:
                    message.serial = reader.int32();
                    break;
                case /* bool state */ 4:
                    message.state = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetIOOutputStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* int32 serial = 3; */
        if (message.serial !== 0)
            writer.tag(3, WireType.Varint).int32(message.serial);
        /* bool state = 4; */
        if (message.state !== false)
            writer.tag(4, WireType.Varint).bool(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SetIOOutputStateRequest
 */
export const SetIOOutputStateRequest = new SetIOOutputStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetIOOutputStateResponse$Type extends MessageType<SetIOOutputStateResponse> {
    constructor() {
        super("rosc.SetIOOutputStateResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetIOOutputStateResponse>): SetIOOutputStateResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetIOOutputStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetIOOutputStateResponse): SetIOOutputStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetIOOutputStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SetIOOutputStateResponse
 */
export const SetIOOutputStateResponse = new SetIOOutputStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIOOutputStateRequest$Type extends MessageType<GetIOOutputStateRequest> {
    constructor() {
        super("rosc.GetIOOutputStateRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetIOOutputStateRequest>): GetIOOutputStateRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIOOutputStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIOOutputStateRequest): GetIOOutputStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIOOutputStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetIOOutputStateRequest
 */
export const GetIOOutputStateRequest = new GetIOOutputStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIOOutputStateResponse$Type extends MessageType<GetIOOutputStateResponse> {
    constructor() {
        super("rosc.GetIOOutputStateResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "states", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "describes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "enable", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetIOOutputStateResponse>): GetIOOutputStateResponse {
        const message = { reply: "", code: 0, states: [], describes: [], enable: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIOOutputStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIOOutputStateResponse): GetIOOutputStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* repeated bool states */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.states.push(reader.bool());
                    else
                        message.states.push(reader.bool());
                    break;
                case /* repeated string describes */ 4:
                    message.describes.push(reader.string());
                    break;
                case /* repeated bool enable */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.enable.push(reader.bool());
                    else
                        message.enable.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIOOutputStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* repeated bool states = 3; */
        if (message.states.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.states.length; i++)
                writer.bool(message.states[i]);
            writer.join();
        }
        /* repeated string describes = 4; */
        for (let i = 0; i < message.describes.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.describes[i]);
        /* repeated bool enable = 5; */
        if (message.enable.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.enable.length; i++)
                writer.bool(message.enable[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetIOOutputStateResponse
 */
export const GetIOOutputStateResponse = new GetIOOutputStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIOInputStateRequest$Type extends MessageType<GetIOInputStateRequest> {
    constructor() {
        super("rosc.GetIOInputStateRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetIOInputStateRequest>): GetIOInputStateRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIOInputStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIOInputStateRequest): GetIOInputStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIOInputStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetIOInputStateRequest
 */
export const GetIOInputStateRequest = new GetIOInputStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIOInputStateResponse$Type extends MessageType<GetIOInputStateResponse> {
    constructor() {
        super("rosc.GetIOInputStateResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "states", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "describes", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "enable", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetIOInputStateResponse>): GetIOInputStateResponse {
        const message = { reply: "", code: 0, states: [], describes: [], enable: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIOInputStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIOInputStateResponse): GetIOInputStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* repeated bool states */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.states.push(reader.bool());
                    else
                        message.states.push(reader.bool());
                    break;
                case /* repeated string describes */ 4:
                    message.describes.push(reader.string());
                    break;
                case /* repeated bool enable */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.enable.push(reader.bool());
                    else
                        message.enable.push(reader.bool());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIOInputStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* repeated bool states = 3; */
        if (message.states.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.states.length; i++)
                writer.bool(message.states[i]);
            writer.join();
        }
        /* repeated string describes = 4; */
        for (let i = 0; i < message.describes.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.describes[i]);
        /* repeated bool enable = 5; */
        if (message.enable.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.enable.length; i++)
                writer.bool(message.enable[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetIOInputStateResponse
 */
export const GetIOInputStateResponse = new GetIOInputStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopGetIOInputStateRequest$Type extends MessageType<StopGetIOInputStateRequest> {
    constructor() {
        super("rosc.StopGetIOInputStateRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StopGetIOInputStateRequest>): StopGetIOInputStateRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StopGetIOInputStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopGetIOInputStateRequest): StopGetIOInputStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopGetIOInputStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.StopGetIOInputStateRequest
 */
export const StopGetIOInputStateRequest = new StopGetIOInputStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopGetIOInputStateResponse$Type extends MessageType<StopGetIOInputStateResponse> {
    constructor() {
        super("rosc.StopGetIOInputStateResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StopGetIOInputStateResponse>): StopGetIOInputStateResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StopGetIOInputStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopGetIOInputStateResponse): StopGetIOInputStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopGetIOInputStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.StopGetIOInputStateResponse
 */
export const StopGetIOInputStateResponse = new StopGetIOInputStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePointRequest$Type extends MessageType<DeletePointRequest> {
    constructor() {
        super("rosc.DeletePointRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeletePointRequest>): DeletePointRequest {
        const message = { message: "", code: 0, name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeletePointRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePointRequest): DeletePointRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletePointRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.DeletePointRequest
 */
export const DeletePointRequest = new DeletePointRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeletePointResponse$Type extends MessageType<DeletePointResponse> {
    constructor() {
        super("rosc.DeletePointResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DeletePointResponse>): DeletePointResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeletePointResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeletePointResponse): DeletePointResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeletePointResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.DeletePointResponse
 */
export const DeletePointResponse = new DeletePointResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllPointNamesRequest$Type extends MessageType<GetAllPointNamesRequest> {
    constructor() {
        super("rosc.GetAllPointNamesRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllPointNamesRequest>): GetAllPointNamesRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAllPointNamesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllPointNamesRequest): GetAllPointNamesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllPointNamesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetAllPointNamesRequest
 */
export const GetAllPointNamesRequest = new GetAllPointNamesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAllPointNamesResponse$Type extends MessageType<GetAllPointNamesResponse> {
    constructor() {
        super("rosc.GetAllPointNamesResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "point_names", kind: "scalar", localName: "point_names", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetAllPointNamesResponse>): GetAllPointNamesResponse {
        const message = { message: "", code: 0, point_names: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAllPointNamesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAllPointNamesResponse): GetAllPointNamesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* repeated string point_names */ 3:
                    message.point_names.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAllPointNamesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* repeated string point_names = 3; */
        for (let i = 0; i < message.point_names.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.point_names[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetAllPointNamesResponse
 */
export const GetAllPointNamesResponse = new GetAllPointNamesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadPointFileRequest$Type extends MessageType<DownloadPointFileRequest> {
    constructor() {
        super("rosc.DownloadPointFileRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DownloadPointFileRequest>): DownloadPointFileRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DownloadPointFileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadPointFileRequest): DownloadPointFileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownloadPointFileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.DownloadPointFileRequest
 */
export const DownloadPointFileRequest = new DownloadPointFileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DownloadPointFileResponse$Type extends MessageType<DownloadPointFileResponse> {
    constructor() {
        super("rosc.DownloadPointFileResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<DownloadPointFileResponse>): DownloadPointFileResponse {
        const message = { reply: "", code: 0, data: new Uint8Array(0) };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DownloadPointFileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DownloadPointFileResponse): DownloadPointFileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DownloadPointFileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.DownloadPointFileResponse
 */
export const DownloadPointFileResponse = new DownloadPointFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveToTeachPositionRequest$Type extends MessageType<MoveToTeachPositionRequest> {
    constructor() {
        super("rosc.MoveToTeachPositionRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MoveToTeachPositionRequest>): MoveToTeachPositionRequest {
        const message = { message: "", code: 0, name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MoveToTeachPositionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveToTeachPositionRequest): MoveToTeachPositionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveToTeachPositionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.MoveToTeachPositionRequest
 */
export const MoveToTeachPositionRequest = new MoveToTeachPositionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveToTeachPositionResponse$Type extends MessageType<MoveToTeachPositionResponse> {
    constructor() {
        super("rosc.MoveToTeachPositionResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MoveToTeachPositionResponse>): MoveToTeachPositionResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MoveToTeachPositionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveToTeachPositionResponse): MoveToTeachPositionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveToTeachPositionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.MoveToTeachPositionResponse
 */
export const MoveToTeachPositionResponse = new MoveToTeachPositionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GoTeachJointRequest$Type extends MessageType<GoTeachJointRequest> {
    constructor() {
        super("rosc.GoTeachJointRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "point_name", kind: "scalar", localName: "point_name", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GoTeachJointRequest>): GoTeachJointRequest {
        const message = { message: "", code: 0, point_name: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GoTeachJointRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GoTeachJointRequest): GoTeachJointRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string point_name */ 3:
                    message.point_name = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GoTeachJointRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string point_name = 3; */
        if (message.point_name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.point_name);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GoTeachJointRequest
 */
export const GoTeachJointRequest = new GoTeachJointRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GoTeachJointResponse$Type extends MessageType<GoTeachJointResponse> {
    constructor() {
        super("rosc.GoTeachJointResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GoTeachJointResponse>): GoTeachJointResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GoTeachJointResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GoTeachJointResponse): GoTeachJointResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GoTeachJointResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GoTeachJointResponse
 */
export const GoTeachJointResponse = new GoTeachJointResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStreamExceptionRequest$Type extends MessageType<GetStreamExceptionRequest> {
    constructor() {
        super("rosc.GetStreamExceptionRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetStreamExceptionRequest>): GetStreamExceptionRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetStreamExceptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStreamExceptionRequest): GetStreamExceptionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStreamExceptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetStreamExceptionRequest
 */
export const GetStreamExceptionRequest = new GetStreamExceptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStreamExceptionResponse$Type extends MessageType<GetStreamExceptionResponse> {
    constructor() {
        super("rosc.GetStreamExceptionResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "status_code", kind: "scalar", localName: "status_code", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "level", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "time", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetStreamExceptionResponse>): GetStreamExceptionResponse {
        const message = { reply: "", code: 0, status_code: "", level: 0, time: "", message: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetStreamExceptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStreamExceptionResponse): GetStreamExceptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string status_code */ 3:
                    message.status_code = reader.string();
                    break;
                case /* int32 level */ 4:
                    message.level = reader.int32();
                    break;
                case /* string time */ 5:
                    message.time = reader.string();
                    break;
                case /* string message */ 6:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStreamExceptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string status_code = 3; */
        if (message.status_code !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.status_code);
        /* int32 level = 4; */
        if (message.level !== 0)
            writer.tag(4, WireType.Varint).int32(message.level);
        /* string time = 5; */
        if (message.time !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.time);
        /* string message = 6; */
        if (message.message !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetStreamExceptionResponse
 */
export const GetStreamExceptionResponse = new GetStreamExceptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExceptionRequest$Type extends MessageType<GetExceptionRequest> {
    constructor() {
        super("rosc.GetExceptionRequest", []);
    }
    create(value?: PartialMessage<GetExceptionRequest>): GetExceptionRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetExceptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetExceptionRequest): GetExceptionRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetExceptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetExceptionRequest
 */
export const GetExceptionRequest = new GetExceptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExceptionResponse$Type extends MessageType<GetExceptionResponse> {
    constructor() {
        super("rosc.GetExceptionResponse", [
            { no: 1, name: "status_code", kind: "scalar", localName: "status_code", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "level", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "time", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "message", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetExceptionResponse>): GetExceptionResponse {
        const message = { status_code: [], level: [], time: [], message: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetExceptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetExceptionResponse): GetExceptionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string status_code */ 1:
                    message.status_code.push(reader.string());
                    break;
                case /* repeated int32 level */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.level.push(reader.int32());
                    else
                        message.level.push(reader.int32());
                    break;
                case /* repeated string time */ 3:
                    message.time.push(reader.string());
                    break;
                case /* repeated string message */ 4:
                    message.message.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetExceptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string status_code = 1; */
        for (let i = 0; i < message.status_code.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.status_code[i]);
        /* repeated int32 level = 2; */
        if (message.level.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.level.length; i++)
                writer.int32(message.level[i]);
            writer.join();
        }
        /* repeated string time = 3; */
        for (let i = 0; i < message.time.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.time[i]);
        /* repeated string message = 4; */
        for (let i = 0; i < message.message.length; i++)
            writer.tag(4, WireType.LengthDelimited).string(message.message[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetExceptionResponse
 */
export const GetExceptionResponse = new GetExceptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteExceptionRequest$Type extends MessageType<DeleteExceptionRequest> {
    constructor() {
        super("rosc.DeleteExceptionRequest", []);
    }
    create(value?: PartialMessage<DeleteExceptionRequest>): DeleteExceptionRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteExceptionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteExceptionRequest): DeleteExceptionRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteExceptionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.DeleteExceptionRequest
 */
export const DeleteExceptionRequest = new DeleteExceptionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteExceptionResponse$Type extends MessageType<DeleteExceptionResponse> {
    constructor() {
        super("rosc.DeleteExceptionResponse", []);
    }
    create(value?: PartialMessage<DeleteExceptionResponse>): DeleteExceptionResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteExceptionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteExceptionResponse): DeleteExceptionResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: DeleteExceptionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.DeleteExceptionResponse
 */
export const DeleteExceptionResponse = new DeleteExceptionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeviceSetting$Type extends MessageType<DeviceSetting> {
    constructor() {
        super("rosc.DeviceSetting", [
            { no: 1, name: "dof", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "IO", kind: "scalar", localName: "IO", jsonName: "IO", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "speed", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<DeviceSetting>): DeviceSetting {
        const message = { dof: 0, IO: 0, speed: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeviceSetting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeviceSetting): DeviceSetting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 dof */ 1:
                    message.dof = reader.int32();
                    break;
                case /* int32 IO = 2 [json_name = "IO"];*/ 2:
                    message.IO = reader.int32();
                    break;
                case /* double speed */ 3:
                    message.speed = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeviceSetting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 dof = 1; */
        if (message.dof !== 0)
            writer.tag(1, WireType.Varint).int32(message.dof);
        /* int32 IO = 2 [json_name = "IO"]; */
        if (message.IO !== 0)
            writer.tag(2, WireType.Varint).int32(message.IO);
        /* double speed = 3; */
        if (message.speed !== 0)
            writer.tag(3, WireType.Bit64).double(message.speed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.DeviceSetting
 */
export const DeviceSetting = new DeviceSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class JointSetting$Type extends MessageType<JointSetting> {
    constructor() {
        super("rosc.JointSetting", [
            { no: 1, name: "joint_name", kind: "scalar", localName: "joint_name", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "vel_max", kind: "scalar", localName: "vel_max", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "acc_max", kind: "scalar", localName: "acc_max", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "jerk", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "MotionRangeStart", kind: "scalar", localName: "MotionRangeStart", jsonName: "MotionRangeStart", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "MotionRangeEnd", kind: "scalar", localName: "MotionRangeEnd", jsonName: "MotionRangeEnd", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "dcc_max", kind: "scalar", localName: "dcc_max", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "dcc_jerk", kind: "scalar", localName: "dcc_jerk", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<JointSetting>): JointSetting {
        const message = { joint_name: [], vel_max: [], acc_max: [], jerk: [], MotionRangeStart: [], MotionRangeEnd: [], dcc_max: [], dcc_jerk: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<JointSetting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JointSetting): JointSetting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated string joint_name */ 1:
                    message.joint_name.push(reader.string());
                    break;
                case /* repeated double vel_max */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.vel_max.push(reader.double());
                    else
                        message.vel_max.push(reader.double());
                    break;
                case /* repeated double acc_max */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.acc_max.push(reader.double());
                    else
                        message.acc_max.push(reader.double());
                    break;
                case /* repeated double jerk */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.jerk.push(reader.double());
                    else
                        message.jerk.push(reader.double());
                    break;
                case /* repeated double MotionRangeStart = 5 [json_name = "MotionRangeStart"];*/ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.MotionRangeStart.push(reader.double());
                    else
                        message.MotionRangeStart.push(reader.double());
                    break;
                case /* repeated double MotionRangeEnd = 6 [json_name = "MotionRangeEnd"];*/ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.MotionRangeEnd.push(reader.double());
                    else
                        message.MotionRangeEnd.push(reader.double());
                    break;
                case /* repeated double dcc_max */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dcc_max.push(reader.double());
                    else
                        message.dcc_max.push(reader.double());
                    break;
                case /* repeated double dcc_jerk */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dcc_jerk.push(reader.double());
                    else
                        message.dcc_jerk.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JointSetting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated string joint_name = 1; */
        for (let i = 0; i < message.joint_name.length; i++)
            writer.tag(1, WireType.LengthDelimited).string(message.joint_name[i]);
        /* repeated double vel_max = 2; */
        if (message.vel_max.length) {
            writer.tag(2, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.vel_max.length; i++)
                writer.double(message.vel_max[i]);
            writer.join();
        }
        /* repeated double acc_max = 3; */
        if (message.acc_max.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.acc_max.length; i++)
                writer.double(message.acc_max[i]);
            writer.join();
        }
        /* repeated double jerk = 4; */
        if (message.jerk.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.jerk.length; i++)
                writer.double(message.jerk[i]);
            writer.join();
        }
        /* repeated double MotionRangeStart = 5 [json_name = "MotionRangeStart"]; */
        if (message.MotionRangeStart.length) {
            writer.tag(5, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.MotionRangeStart.length; i++)
                writer.double(message.MotionRangeStart[i]);
            writer.join();
        }
        /* repeated double MotionRangeEnd = 6 [json_name = "MotionRangeEnd"]; */
        if (message.MotionRangeEnd.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.MotionRangeEnd.length; i++)
                writer.double(message.MotionRangeEnd[i]);
            writer.join();
        }
        /* repeated double dcc_max = 7; */
        if (message.dcc_max.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.dcc_max.length; i++)
                writer.double(message.dcc_max[i]);
            writer.join();
        }
        /* repeated double dcc_jerk = 8; */
        if (message.dcc_jerk.length) {
            writer.tag(8, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.dcc_jerk.length; i++)
                writer.double(message.dcc_jerk[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.JointSetting
 */
export const JointSetting = new JointSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IOSetting$Type extends MessageType<IOSetting> {
    constructor() {
        super("rosc.IOSetting", [
            { no: 1, name: "IO_seq_l", kind: "scalar", localName: "IO_seq_l", jsonName: "IOSeqL", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "IO_seq_r", kind: "scalar", localName: "IO_seq_r", jsonName: "IOSeqR", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "wafer_confirm_out_l", kind: "scalar", localName: "wafer_confirm_out_l", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "wafer_confirm_out_r", kind: "scalar", localName: "wafer_confirm_out_r", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "user_mode", kind: "scalar", localName: "user_mode", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "err_signal", kind: "scalar", localName: "err_signal", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "ready_signal", kind: "scalar", localName: "ready_signal", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "PA_ready_signal", kind: "scalar", localName: "PA_ready_signal", jsonName: "PAReadySignal", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "wafer_sensor_l", kind: "scalar", localName: "wafer_sensor_l", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "wafer_sensor_r", kind: "scalar", localName: "wafer_sensor_r", T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "mapping_sensor", kind: "scalar", localName: "mapping_sensor", T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "wafer_sensor_lr", kind: "scalar", localName: "wafer_sensor_lr", T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "wafer_sensor_rr", kind: "scalar", localName: "wafer_sensor_rr", T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "IO_seq_lr", kind: "scalar", localName: "IO_seq_lr", jsonName: "IOSeqLr", T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "IO_seq_rr", kind: "scalar", localName: "IO_seq_rr", jsonName: "IOSeqRr", T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "wafer_confirm_out_lr", kind: "scalar", localName: "wafer_confirm_out_lr", T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "wafer_confirm_out_rr", kind: "scalar", localName: "wafer_confirm_out_rr", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<IOSetting>): IOSetting {
        const message = { IO_seq_l: 0, IO_seq_r: 0, wafer_confirm_out_l: 0, wafer_confirm_out_r: 0, user_mode: 0, err_signal: 0, ready_signal: 0, PA_ready_signal: 0, wafer_sensor_l: 0, wafer_sensor_r: 0, mapping_sensor: 0, wafer_sensor_lr: 0, wafer_sensor_rr: 0, IO_seq_lr: 0, IO_seq_rr: 0, wafer_confirm_out_lr: 0, wafer_confirm_out_rr: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IOSetting>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IOSetting): IOSetting {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 IO_seq_l = 1 [json_name = "IOSeqL"];*/ 1:
                    message.IO_seq_l = reader.int32();
                    break;
                case /* int32 IO_seq_r = 2 [json_name = "IOSeqR"];*/ 2:
                    message.IO_seq_r = reader.int32();
                    break;
                case /* int32 wafer_confirm_out_l */ 3:
                    message.wafer_confirm_out_l = reader.int32();
                    break;
                case /* int32 wafer_confirm_out_r */ 4:
                    message.wafer_confirm_out_r = reader.int32();
                    break;
                case /* int32 user_mode */ 5:
                    message.user_mode = reader.int32();
                    break;
                case /* int32 err_signal */ 6:
                    message.err_signal = reader.int32();
                    break;
                case /* int32 ready_signal */ 7:
                    message.ready_signal = reader.int32();
                    break;
                case /* int32 PA_ready_signal = 8 [json_name = "PAReadySignal"];*/ 8:
                    message.PA_ready_signal = reader.int32();
                    break;
                case /* int32 wafer_sensor_l */ 9:
                    message.wafer_sensor_l = reader.int32();
                    break;
                case /* int32 wafer_sensor_r */ 10:
                    message.wafer_sensor_r = reader.int32();
                    break;
                case /* int32 mapping_sensor */ 11:
                    message.mapping_sensor = reader.int32();
                    break;
                case /* int32 wafer_sensor_lr */ 12:
                    message.wafer_sensor_lr = reader.int32();
                    break;
                case /* int32 wafer_sensor_rr */ 13:
                    message.wafer_sensor_rr = reader.int32();
                    break;
                case /* int32 IO_seq_lr = 14 [json_name = "IOSeqLr"];*/ 14:
                    message.IO_seq_lr = reader.int32();
                    break;
                case /* int32 IO_seq_rr = 15 [json_name = "IOSeqRr"];*/ 15:
                    message.IO_seq_rr = reader.int32();
                    break;
                case /* int32 wafer_confirm_out_lr */ 16:
                    message.wafer_confirm_out_lr = reader.int32();
                    break;
                case /* int32 wafer_confirm_out_rr */ 17:
                    message.wafer_confirm_out_rr = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IOSetting, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 IO_seq_l = 1 [json_name = "IOSeqL"]; */
        if (message.IO_seq_l !== 0)
            writer.tag(1, WireType.Varint).int32(message.IO_seq_l);
        /* int32 IO_seq_r = 2 [json_name = "IOSeqR"]; */
        if (message.IO_seq_r !== 0)
            writer.tag(2, WireType.Varint).int32(message.IO_seq_r);
        /* int32 wafer_confirm_out_l = 3; */
        if (message.wafer_confirm_out_l !== 0)
            writer.tag(3, WireType.Varint).int32(message.wafer_confirm_out_l);
        /* int32 wafer_confirm_out_r = 4; */
        if (message.wafer_confirm_out_r !== 0)
            writer.tag(4, WireType.Varint).int32(message.wafer_confirm_out_r);
        /* int32 user_mode = 5; */
        if (message.user_mode !== 0)
            writer.tag(5, WireType.Varint).int32(message.user_mode);
        /* int32 err_signal = 6; */
        if (message.err_signal !== 0)
            writer.tag(6, WireType.Varint).int32(message.err_signal);
        /* int32 ready_signal = 7; */
        if (message.ready_signal !== 0)
            writer.tag(7, WireType.Varint).int32(message.ready_signal);
        /* int32 PA_ready_signal = 8 [json_name = "PAReadySignal"]; */
        if (message.PA_ready_signal !== 0)
            writer.tag(8, WireType.Varint).int32(message.PA_ready_signal);
        /* int32 wafer_sensor_l = 9; */
        if (message.wafer_sensor_l !== 0)
            writer.tag(9, WireType.Varint).int32(message.wafer_sensor_l);
        /* int32 wafer_sensor_r = 10; */
        if (message.wafer_sensor_r !== 0)
            writer.tag(10, WireType.Varint).int32(message.wafer_sensor_r);
        /* int32 mapping_sensor = 11; */
        if (message.mapping_sensor !== 0)
            writer.tag(11, WireType.Varint).int32(message.mapping_sensor);
        /* int32 wafer_sensor_lr = 12; */
        if (message.wafer_sensor_lr !== 0)
            writer.tag(12, WireType.Varint).int32(message.wafer_sensor_lr);
        /* int32 wafer_sensor_rr = 13; */
        if (message.wafer_sensor_rr !== 0)
            writer.tag(13, WireType.Varint).int32(message.wafer_sensor_rr);
        /* int32 IO_seq_lr = 14 [json_name = "IOSeqLr"]; */
        if (message.IO_seq_lr !== 0)
            writer.tag(14, WireType.Varint).int32(message.IO_seq_lr);
        /* int32 IO_seq_rr = 15 [json_name = "IOSeqRr"]; */
        if (message.IO_seq_rr !== 0)
            writer.tag(15, WireType.Varint).int32(message.IO_seq_rr);
        /* int32 wafer_confirm_out_lr = 16; */
        if (message.wafer_confirm_out_lr !== 0)
            writer.tag(16, WireType.Varint).int32(message.wafer_confirm_out_lr);
        /* int32 wafer_confirm_out_rr = 17; */
        if (message.wafer_confirm_out_rr !== 0)
            writer.tag(17, WireType.Varint).int32(message.wafer_confirm_out_rr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.IOSetting
 */
export const IOSetting = new IOSetting$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveJointSettingItem$Type extends MessageType<SaveJointSettingItem> {
    constructor() {
        super("rosc.SaveJointSettingItem", [
            { no: 1, name: "axis_name", kind: "scalar", localName: "axis_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "attribute", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SaveJointSettingItem>): SaveJointSettingItem {
        const message = { axis_name: "", attribute: "", value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveJointSettingItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveJointSettingItem): SaveJointSettingItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string axis_name */ 1:
                    message.axis_name = reader.string();
                    break;
                case /* string attribute */ 2:
                    message.attribute = reader.string();
                    break;
                case /* double value */ 3:
                    message.value = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveJointSettingItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string axis_name = 1; */
        if (message.axis_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.axis_name);
        /* string attribute = 2; */
        if (message.attribute !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.attribute);
        /* double value = 3; */
        if (message.value !== 0)
            writer.tag(3, WireType.Bit64).double(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveJointSettingItem
 */
export const SaveJointSettingItem = new SaveJointSettingItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveJointSettingRequest$Type extends MessageType<SaveJointSettingRequest> {
    constructor() {
        super("rosc.SaveJointSettingRequest", [
            { no: 1, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SaveJointSettingItem },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SaveJointSettingRequest>): SaveJointSettingRequest {
        const message = { data: [], message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveJointSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveJointSettingRequest): SaveJointSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated rosc.SaveJointSettingItem data */ 1:
                    message.data.push(SaveJointSettingItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 3:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveJointSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated rosc.SaveJointSettingItem data = 1; */
        for (let i = 0; i < message.data.length; i++)
            SaveJointSettingItem.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* int32 code = 3; */
        if (message.code !== 0)
            writer.tag(3, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveJointSettingRequest
 */
export const SaveJointSettingRequest = new SaveJointSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveJointSettingResponse$Type extends MessageType<SaveJointSettingResponse> {
    constructor() {
        super("rosc.SaveJointSettingResponse", [
            { no: 2, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SaveJointSettingResponse>): SaveJointSettingResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveJointSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveJointSettingResponse): SaveJointSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 2:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 3:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveJointSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 2; */
        if (message.reply !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 3; */
        if (message.code !== 0)
            writer.tag(3, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveJointSettingResponse
 */
export const SaveJointSettingResponse = new SaveJointSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveIOSettingItem$Type extends MessageType<SaveIOSettingItem> {
    constructor() {
        super("rosc.SaveIOSettingItem", [
            { no: 1, name: "attribute", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SaveIOSettingItem>): SaveIOSettingItem {
        const message = { attribute: "", value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveIOSettingItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveIOSettingItem): SaveIOSettingItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string attribute */ 1:
                    message.attribute = reader.string();
                    break;
                case /* int32 value */ 2:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveIOSettingItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string attribute = 1; */
        if (message.attribute !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.attribute);
        /* int32 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveIOSettingItem
 */
export const SaveIOSettingItem = new SaveIOSettingItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveIOSettingRequest$Type extends MessageType<SaveIOSettingRequest> {
    constructor() {
        super("rosc.SaveIOSettingRequest", [
            { no: 1, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SaveIOSettingItem },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SaveIOSettingRequest>): SaveIOSettingRequest {
        const message = { data: [], message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveIOSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveIOSettingRequest): SaveIOSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated rosc.SaveIOSettingItem data */ 1:
                    message.data.push(SaveIOSettingItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 3:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveIOSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated rosc.SaveIOSettingItem data = 1; */
        for (let i = 0; i < message.data.length; i++)
            SaveIOSettingItem.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* int32 code = 3; */
        if (message.code !== 0)
            writer.tag(3, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveIOSettingRequest
 */
export const SaveIOSettingRequest = new SaveIOSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveIOSettingResponse$Type extends MessageType<SaveIOSettingResponse> {
    constructor() {
        super("rosc.SaveIOSettingResponse", [
            { no: 2, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SaveIOSettingResponse>): SaveIOSettingResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveIOSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveIOSettingResponse): SaveIOSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 2:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 3:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveIOSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 2; */
        if (message.reply !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 3; */
        if (message.code !== 0)
            writer.tag(3, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveIOSettingResponse
 */
export const SaveIOSettingResponse = new SaveIOSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RobotSettingRequest$Type extends MessageType<RobotSettingRequest> {
    constructor() {
        super("rosc.RobotSettingRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "setting_type", kind: "scalar", localName: "setting_type", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RobotSettingRequest>): RobotSettingRequest {
        const message = { message: "", code: 0, setting_type: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RobotSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RobotSettingRequest): RobotSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string setting_type */ 3:
                    message.setting_type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RobotSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string setting_type = 3; */
        if (message.setting_type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.setting_type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.RobotSettingRequest
 */
export const RobotSettingRequest = new RobotSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RobotSettingResponse$Type extends MessageType<RobotSettingResponse> {
    constructor() {
        super("rosc.RobotSettingResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "setting_type", kind: "scalar", localName: "setting_type", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "joint_setting", kind: "message", localName: "joint_setting", T: () => JointSetting },
            { no: 5, name: "device_setting", kind: "message", localName: "device_setting", T: () => DeviceSetting },
            { no: 6, name: "io_setting", kind: "message", localName: "io_setting", T: () => IOSetting }
        ]);
    }
    create(value?: PartialMessage<RobotSettingResponse>): RobotSettingResponse {
        const message = { reply: "", code: 0, setting_type: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RobotSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RobotSettingResponse): RobotSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string setting_type */ 3:
                    message.setting_type = reader.string();
                    break;
                case /* rosc.JointSetting joint_setting */ 4:
                    message.joint_setting = JointSetting.internalBinaryRead(reader, reader.uint32(), options, message.joint_setting);
                    break;
                case /* rosc.DeviceSetting device_setting */ 5:
                    message.device_setting = DeviceSetting.internalBinaryRead(reader, reader.uint32(), options, message.device_setting);
                    break;
                case /* rosc.IOSetting io_setting */ 6:
                    message.io_setting = IOSetting.internalBinaryRead(reader, reader.uint32(), options, message.io_setting);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RobotSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string setting_type = 3; */
        if (message.setting_type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.setting_type);
        /* rosc.JointSetting joint_setting = 4; */
        if (message.joint_setting)
            JointSetting.internalBinaryWrite(message.joint_setting, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* rosc.DeviceSetting device_setting = 5; */
        if (message.device_setting)
            DeviceSetting.internalBinaryWrite(message.device_setting, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* rosc.IOSetting io_setting = 6; */
        if (message.io_setting)
            IOSetting.internalBinaryWrite(message.io_setting, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.RobotSettingResponse
 */
export const RobotSettingResponse = new RobotSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetJointSettingResponse$Type extends MessageType<GetJointSettingResponse> {
    constructor() {
        super("rosc.GetJointSettingResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "joint_setting", kind: "message", localName: "joint_setting", T: () => JointSetting }
        ]);
    }
    create(value?: PartialMessage<GetJointSettingResponse>): GetJointSettingResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetJointSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetJointSettingResponse): GetJointSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* rosc.JointSetting joint_setting */ 3:
                    message.joint_setting = JointSetting.internalBinaryRead(reader, reader.uint32(), options, message.joint_setting);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetJointSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* rosc.JointSetting joint_setting = 3; */
        if (message.joint_setting)
            JointSetting.internalBinaryWrite(message.joint_setting, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetJointSettingResponse
 */
export const GetJointSettingResponse = new GetJointSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDeviceSettingResponse$Type extends MessageType<GetDeviceSettingResponse> {
    constructor() {
        super("rosc.GetDeviceSettingResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "device_setting", kind: "message", localName: "device_setting", T: () => DeviceSetting }
        ]);
    }
    create(value?: PartialMessage<GetDeviceSettingResponse>): GetDeviceSettingResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDeviceSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDeviceSettingResponse): GetDeviceSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* rosc.DeviceSetting device_setting */ 5:
                    message.device_setting = DeviceSetting.internalBinaryRead(reader, reader.uint32(), options, message.device_setting);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDeviceSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* rosc.DeviceSetting device_setting = 5; */
        if (message.device_setting)
            DeviceSetting.internalBinaryWrite(message.device_setting, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetDeviceSettingResponse
 */
export const GetDeviceSettingResponse = new GetDeviceSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIOSettingResponse$Type extends MessageType<GetIOSettingResponse> {
    constructor() {
        super("rosc.GetIOSettingResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "io_setting", kind: "message", localName: "io_setting", T: () => IOSetting }
        ]);
    }
    create(value?: PartialMessage<GetIOSettingResponse>): GetIOSettingResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIOSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIOSettingResponse): GetIOSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* rosc.IOSetting io_setting */ 6:
                    message.io_setting = IOSetting.internalBinaryRead(reader, reader.uint32(), options, message.io_setting);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIOSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* rosc.IOSetting io_setting = 6; */
        if (message.io_setting)
            IOSetting.internalBinaryWrite(message.io_setting, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetIOSettingResponse
 */
export const GetIOSettingResponse = new GetIOSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachInstructionRequest$Type extends MessageType<TeachInstructionRequest> {
    constructor() {
        super("rosc.TeachInstructionRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "op_type", kind: "scalar", localName: "op_type", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "speed", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "start_point", kind: "scalar", localName: "start_point", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "mid_point", kind: "scalar", localName: "mid_point", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "end_point", kind: "scalar", localName: "end_point", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "sleep_time", kind: "scalar", localName: "sleep_time", T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "arm", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "fixBlade", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TeachInstructionRequest>): TeachInstructionRequest {
        const message = { message: "", code: 0, op_type: "", speed: 0, start_point: "", mid_point: "", end_point: "", sleep_time: 0, arm: "", fixBlade: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachInstructionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachInstructionRequest): TeachInstructionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string op_type */ 3:
                    message.op_type = reader.string();
                    break;
                case /* int32 speed */ 4:
                    message.speed = reader.int32();
                    break;
                case /* string start_point */ 5:
                    message.start_point = reader.string();
                    break;
                case /* string mid_point */ 6:
                    message.mid_point = reader.string();
                    break;
                case /* string end_point */ 7:
                    message.end_point = reader.string();
                    break;
                case /* int32 sleep_time */ 8:
                    message.sleep_time = reader.int32();
                    break;
                case /* string arm */ 9:
                    message.arm = reader.string();
                    break;
                case /* string fixBlade */ 10:
                    message.fixBlade = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachInstructionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string op_type = 3; */
        if (message.op_type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.op_type);
        /* int32 speed = 4; */
        if (message.speed !== 0)
            writer.tag(4, WireType.Varint).int32(message.speed);
        /* string start_point = 5; */
        if (message.start_point !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.start_point);
        /* string mid_point = 6; */
        if (message.mid_point !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.mid_point);
        /* string end_point = 7; */
        if (message.end_point !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.end_point);
        /* int32 sleep_time = 8; */
        if (message.sleep_time !== 0)
            writer.tag(8, WireType.Varint).int32(message.sleep_time);
        /* string arm = 9; */
        if (message.arm !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.arm);
        /* string fixBlade = 10; */
        if (message.fixBlade !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.fixBlade);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachInstructionRequest
 */
export const TeachInstructionRequest = new TeachInstructionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeachInstructionResponse$Type extends MessageType<TeachInstructionResponse> {
    constructor() {
        super("rosc.TeachInstructionResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeachInstructionResponse>): TeachInstructionResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeachInstructionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeachInstructionResponse): TeachInstructionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeachInstructionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.TeachInstructionResponse
 */
export const TeachInstructionResponse = new TeachInstructionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPutWaferRequest$Type extends MessageType<GetPutWaferRequest> {
    constructor() {
        super("rosc.GetPutWaferRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "start_arm", kind: "scalar", localName: "start_arm", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "start_cassette", kind: "scalar", localName: "start_cassette", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "start_slot", kind: "scalar", localName: "start_slot", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "end_cassette", kind: "scalar", localName: "end_cassette", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "end_slot", kind: "scalar", localName: "end_slot", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "start_arm_posture", kind: "scalar", localName: "start_arm_posture", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "end_arm", kind: "scalar", localName: "end_arm", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "end_arm_posture", kind: "scalar", localName: "end_arm_posture", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetPutWaferRequest>): GetPutWaferRequest {
        const message = { message: "", code: 0, start_arm: 0, start_cassette: "", start_slot: 0, end_cassette: "", end_slot: 0, start_arm_posture: "", end_arm: 0, end_arm_posture: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPutWaferRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPutWaferRequest): GetPutWaferRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* int32 start_arm */ 3:
                    message.start_arm = reader.int32();
                    break;
                case /* string start_cassette */ 4:
                    message.start_cassette = reader.string();
                    break;
                case /* int32 start_slot */ 5:
                    message.start_slot = reader.int32();
                    break;
                case /* string end_cassette */ 6:
                    message.end_cassette = reader.string();
                    break;
                case /* int32 end_slot */ 7:
                    message.end_slot = reader.int32();
                    break;
                case /* string start_arm_posture */ 8:
                    message.start_arm_posture = reader.string();
                    break;
                case /* int32 end_arm */ 9:
                    message.end_arm = reader.int32();
                    break;
                case /* string end_arm_posture */ 10:
                    message.end_arm_posture = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPutWaferRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* int32 start_arm = 3; */
        if (message.start_arm !== 0)
            writer.tag(3, WireType.Varint).int32(message.start_arm);
        /* string start_cassette = 4; */
        if (message.start_cassette !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.start_cassette);
        /* int32 start_slot = 5; */
        if (message.start_slot !== 0)
            writer.tag(5, WireType.Varint).int32(message.start_slot);
        /* string end_cassette = 6; */
        if (message.end_cassette !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.end_cassette);
        /* int32 end_slot = 7; */
        if (message.end_slot !== 0)
            writer.tag(7, WireType.Varint).int32(message.end_slot);
        /* string start_arm_posture = 8; */
        if (message.start_arm_posture !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.start_arm_posture);
        /* int32 end_arm = 9; */
        if (message.end_arm !== 0)
            writer.tag(9, WireType.Varint).int32(message.end_arm);
        /* string end_arm_posture = 10; */
        if (message.end_arm_posture !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.end_arm_posture);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetPutWaferRequest
 */
export const GetPutWaferRequest = new GetPutWaferRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPutWaferResponse$Type extends MessageType<GetPutWaferResponse> {
    constructor() {
        super("rosc.GetPutWaferResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetPutWaferResponse>): GetPutWaferResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPutWaferResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPutWaferResponse): GetPutWaferResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPutWaferResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetPutWaferResponse
 */
export const GetPutWaferResponse = new GetPutWaferResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPutWaferStopRequest$Type extends MessageType<GetPutWaferStopRequest> {
    constructor() {
        super("rosc.GetPutWaferStopRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetPutWaferStopRequest>): GetPutWaferStopRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPutWaferStopRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPutWaferStopRequest): GetPutWaferStopRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPutWaferStopRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetPutWaferStopRequest
 */
export const GetPutWaferStopRequest = new GetPutWaferStopRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPutWaferStopResponse$Type extends MessageType<GetPutWaferStopResponse> {
    constructor() {
        super("rosc.GetPutWaferStopResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetPutWaferStopResponse>): GetPutWaferStopResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPutWaferStopResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPutWaferStopResponse): GetPutWaferStopResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPutWaferStopResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetPutWaferStopResponse
 */
export const GetPutWaferStopResponse = new GetPutWaferStopResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperateWaferRequest$Type extends MessageType<OperateWaferRequest> {
    constructor() {
        super("rosc.OperateWaferRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "arm", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "aim_point", kind: "scalar", localName: "aim_point", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "aim_slot", kind: "scalar", localName: "aim_slot", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "arm_posture", kind: "scalar", localName: "arm_posture", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OperateWaferRequest>): OperateWaferRequest {
        const message = { message: "", code: 0, type: "", arm: 0, aim_point: "", aim_slot: 0, arm_posture: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperateWaferRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperateWaferRequest): OperateWaferRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                case /* int32 arm */ 4:
                    message.arm = reader.int32();
                    break;
                case /* string aim_point */ 5:
                    message.aim_point = reader.string();
                    break;
                case /* int32 aim_slot */ 6:
                    message.aim_slot = reader.int32();
                    break;
                case /* string arm_posture */ 7:
                    message.arm_posture = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperateWaferRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* int32 arm = 4; */
        if (message.arm !== 0)
            writer.tag(4, WireType.Varint).int32(message.arm);
        /* string aim_point = 5; */
        if (message.aim_point !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.aim_point);
        /* int32 aim_slot = 6; */
        if (message.aim_slot !== 0)
            writer.tag(6, WireType.Varint).int32(message.aim_slot);
        /* string arm_posture = 7; */
        if (message.arm_posture !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.arm_posture);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.OperateWaferRequest
 */
export const OperateWaferRequest = new OperateWaferRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperateWaferResponse$Type extends MessageType<OperateWaferResponse> {
    constructor() {
        super("rosc.OperateWaferResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<OperateWaferResponse>): OperateWaferResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperateWaferResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperateWaferResponse): OperateWaferResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperateWaferResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.OperateWaferResponse
 */
export const OperateWaferResponse = new OperateWaferResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DebugWaferRequest$Type extends MessageType<DebugWaferRequest> {
    constructor() {
        super("rosc.DebugWaferRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "arm", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "aim_point", kind: "scalar", localName: "aim_point", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "aim_slot", kind: "scalar", localName: "aim_slot", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "step", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "arm_posture", kind: "scalar", localName: "arm_posture", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DebugWaferRequest>): DebugWaferRequest {
        const message = { message: "", code: 0, type: "", arm: 0, aim_point: "", aim_slot: 0, step: 0, arm_posture: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DebugWaferRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DebugWaferRequest): DebugWaferRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string type */ 3:
                    message.type = reader.string();
                    break;
                case /* int32 arm */ 4:
                    message.arm = reader.int32();
                    break;
                case /* string aim_point */ 5:
                    message.aim_point = reader.string();
                    break;
                case /* int32 aim_slot */ 6:
                    message.aim_slot = reader.int32();
                    break;
                case /* int32 step */ 7:
                    message.step = reader.int32();
                    break;
                case /* string arm_posture */ 8:
                    message.arm_posture = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DebugWaferRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string type = 3; */
        if (message.type !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.type);
        /* int32 arm = 4; */
        if (message.arm !== 0)
            writer.tag(4, WireType.Varint).int32(message.arm);
        /* string aim_point = 5; */
        if (message.aim_point !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.aim_point);
        /* int32 aim_slot = 6; */
        if (message.aim_slot !== 0)
            writer.tag(6, WireType.Varint).int32(message.aim_slot);
        /* int32 step = 7; */
        if (message.step !== 0)
            writer.tag(7, WireType.Varint).int32(message.step);
        /* string arm_posture = 8; */
        if (message.arm_posture !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.arm_posture);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.DebugWaferRequest
 */
export const DebugWaferRequest = new DebugWaferRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DebugWaferResponse$Type extends MessageType<DebugWaferResponse> {
    constructor() {
        super("rosc.DebugWaferResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "step", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "all_step", kind: "scalar", localName: "all_step", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<DebugWaferResponse>): DebugWaferResponse {
        const message = { reply: "", code: 0, message: "", step: 0, all_step: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DebugWaferResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DebugWaferResponse): DebugWaferResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* int32 step */ 4:
                    message.step = reader.int32();
                    break;
                case /* int32 all_step */ 5:
                    message.all_step = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DebugWaferResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* int32 step = 4; */
        if (message.step !== 0)
            writer.tag(4, WireType.Varint).int32(message.step);
        /* int32 all_step = 5; */
        if (message.all_step !== 0)
            writer.tag(5, WireType.Varint).int32(message.all_step);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.DebugWaferResponse
 */
export const DebugWaferResponse = new DebugWaferResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlaveStateRequest$Type extends MessageType<SlaveStateRequest> {
    constructor() {
        super("rosc.SlaveStateRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SlaveStateRequest>): SlaveStateRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SlaveStateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SlaveStateRequest): SlaveStateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SlaveStateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SlaveStateRequest
 */
export const SlaveStateRequest = new SlaveStateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SlaveStateResponse$Type extends MessageType<SlaveStateResponse> {
    constructor() {
        super("rosc.SlaveStateResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "torque", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "velocity", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "error_code", kind: "scalar", localName: "error_code", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SlaveStateResponse>): SlaveStateResponse {
        const message = { reply: "", code: 0, torque: [], velocity: [], error_code: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SlaveStateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SlaveStateResponse): SlaveStateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* repeated double torque */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.torque.push(reader.double());
                    else
                        message.torque.push(reader.double());
                    break;
                case /* repeated double velocity */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.velocity.push(reader.double());
                    else
                        message.velocity.push(reader.double());
                    break;
                case /* repeated string error_code */ 5:
                    message.error_code.push(reader.string());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SlaveStateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* repeated double torque = 3; */
        if (message.torque.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.torque.length; i++)
                writer.double(message.torque[i]);
            writer.join();
        }
        /* repeated double velocity = 4; */
        if (message.velocity.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.velocity.length; i++)
                writer.double(message.velocity[i]);
            writer.join();
        }
        /* repeated string error_code = 5; */
        for (let i = 0; i < message.error_code.length; i++)
            writer.tag(5, WireType.LengthDelimited).string(message.error_code[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SlaveStateResponse
 */
export const SlaveStateResponse = new SlaveStateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadPort$Type extends MessageType<LoadPort> {
    constructor() {
        super("rosc.LoadPort", [
            { no: 1, name: "x", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "y", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "angle", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<LoadPort>): LoadPort {
        const message = { x: 0, y: 0, angle: 0, type: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LoadPort>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadPort): LoadPort {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double x */ 1:
                    message.x = reader.double();
                    break;
                case /* double y */ 2:
                    message.y = reader.double();
                    break;
                case /* double angle */ 3:
                    message.angle = reader.double();
                    break;
                case /* string type */ 4:
                    message.type = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadPort, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double x = 1; */
        if (message.x !== 0)
            writer.tag(1, WireType.Bit64).double(message.x);
        /* double y = 2; */
        if (message.y !== 0)
            writer.tag(2, WireType.Bit64).double(message.y);
        /* double angle = 3; */
        if (message.angle !== 0)
            writer.tag(3, WireType.Bit64).double(message.angle);
        /* string type = 4; */
        if (message.type !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.type);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.LoadPort
 */
export const LoadPort = new LoadPort$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartLayoutSimulationRequest$Type extends MessageType<StartLayoutSimulationRequest> {
    constructor() {
        super("rosc.StartLayoutSimulationRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "pos_list", kind: "message", localName: "pos_list", repeat: 1 /*RepeatType.PACKED*/, T: () => LoadPort }
        ]);
    }
    create(value?: PartialMessage<StartLayoutSimulationRequest>): StartLayoutSimulationRequest {
        const message = { message: "", code: 0, pos_list: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartLayoutSimulationRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartLayoutSimulationRequest): StartLayoutSimulationRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* repeated rosc.LoadPort pos_list */ 3:
                    message.pos_list.push(LoadPort.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartLayoutSimulationRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* repeated rosc.LoadPort pos_list = 3; */
        for (let i = 0; i < message.pos_list.length; i++)
            LoadPort.internalBinaryWrite(message.pos_list[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.StartLayoutSimulationRequest
 */
export const StartLayoutSimulationRequest = new StartLayoutSimulationRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartLayoutSimulationResponse$Type extends MessageType<StartLayoutSimulationResponse> {
    constructor() {
        super("rosc.StartLayoutSimulationResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "access", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StartLayoutSimulationResponse>): StartLayoutSimulationResponse {
        const message = { reply: "", code: 0, access: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartLayoutSimulationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartLayoutSimulationResponse): StartLayoutSimulationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* bool access */ 3:
                    message.access = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartLayoutSimulationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* bool access = 3; */
        if (message.access !== false)
            writer.tag(3, WireType.Varint).bool(message.access);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.StartLayoutSimulationResponse
 */
export const StartLayoutSimulationResponse = new StartLayoutSimulationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLayoutRobotPositionRequest$Type extends MessageType<GetLayoutRobotPositionRequest> {
    constructor() {
        super("rosc.GetLayoutRobotPositionRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetLayoutRobotPositionRequest>): GetLayoutRobotPositionRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetLayoutRobotPositionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLayoutRobotPositionRequest): GetLayoutRobotPositionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLayoutRobotPositionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetLayoutRobotPositionRequest
 */
export const GetLayoutRobotPositionRequest = new GetLayoutRobotPositionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetLayoutRobotPositionResponse$Type extends MessageType<GetLayoutRobotPositionResponse> {
    constructor() {
        super("rosc.GetLayoutRobotPositionResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "position", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<GetLayoutRobotPositionResponse>): GetLayoutRobotPositionResponse {
        const message = { reply: "", code: 0, position: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetLayoutRobotPositionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetLayoutRobotPositionResponse): GetLayoutRobotPositionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* repeated double position */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.position.push(reader.double());
                    else
                        message.position.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetLayoutRobotPositionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* repeated double position = 3; */
        if (message.position.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.position.length; i++)
                writer.double(message.position[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetLayoutRobotPositionResponse
 */
export const GetLayoutRobotPositionResponse = new GetLayoutRobotPositionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopGetLayoutRobotPositionRequest$Type extends MessageType<StopGetLayoutRobotPositionRequest> {
    constructor() {
        super("rosc.StopGetLayoutRobotPositionRequest", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StopGetLayoutRobotPositionRequest>): StopGetLayoutRobotPositionRequest {
        const message = { message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StopGetLayoutRobotPositionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopGetLayoutRobotPositionRequest): StopGetLayoutRobotPositionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopGetLayoutRobotPositionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.StopGetLayoutRobotPositionRequest
 */
export const StopGetLayoutRobotPositionRequest = new StopGetLayoutRobotPositionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StopGetLayoutRobotPositionResponse$Type extends MessageType<StopGetLayoutRobotPositionResponse> {
    constructor() {
        super("rosc.StopGetLayoutRobotPositionResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StopGetLayoutRobotPositionResponse>): StopGetLayoutRobotPositionResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StopGetLayoutRobotPositionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StopGetLayoutRobotPositionResponse): StopGetLayoutRobotPositionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StopGetLayoutRobotPositionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.StopGetLayoutRobotPositionResponse
 */
export const StopGetLayoutRobotPositionResponse = new StopGetLayoutRobotPositionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SingleAxisZeroCalibrateRequest$Type extends MessageType<SingleAxisZeroCalibrateRequest> {
    constructor() {
        super("rosc.SingleAxisZeroCalibrateRequest", [
            { no: 1, name: "axis", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SingleAxisZeroCalibrateRequest>): SingleAxisZeroCalibrateRequest {
        const message = { axis: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SingleAxisZeroCalibrateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SingleAxisZeroCalibrateRequest): SingleAxisZeroCalibrateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 axis */ 1:
                    message.axis = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SingleAxisZeroCalibrateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 axis = 1; */
        if (message.axis !== 0)
            writer.tag(1, WireType.Varint).int32(message.axis);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SingleAxisZeroCalibrateRequest
 */
export const SingleAxisZeroCalibrateRequest = new SingleAxisZeroCalibrateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SingleAxisZeroCalibrateResponse$Type extends MessageType<SingleAxisZeroCalibrateResponse> {
    constructor() {
        super("rosc.SingleAxisZeroCalibrateResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SingleAxisZeroCalibrateResponse>): SingleAxisZeroCalibrateResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SingleAxisZeroCalibrateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SingleAxisZeroCalibrateResponse): SingleAxisZeroCalibrateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SingleAxisZeroCalibrateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SingleAxisZeroCalibrateResponse
 */
export const SingleAxisZeroCalibrateResponse = new SingleAxisZeroCalibrateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpeedConfig$Type extends MessageType<SpeedConfig> {
    constructor() {
        super("rosc.SpeedConfig", [
            { no: 1, name: "attribute", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SpeedConfig>): SpeedConfig {
        const message = { attribute: "", value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SpeedConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpeedConfig): SpeedConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string attribute */ 1:
                    message.attribute = reader.string();
                    break;
                case /* double value */ 2:
                    message.value = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpeedConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string attribute = 1; */
        if (message.attribute !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.attribute);
        /* double value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit64).double(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SpeedConfig
 */
export const SpeedConfig = new SpeedConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSpeedConfigRequest$Type extends MessageType<GetSpeedConfigRequest> {
    constructor() {
        super("rosc.GetSpeedConfigRequest", [
            { no: 1, name: "speed_type", kind: "scalar", localName: "speed_type", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "speed_level", kind: "scalar", localName: "speed_level", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "joint", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSpeedConfigRequest>): GetSpeedConfigRequest {
        const message = { speed_type: "", speed_level: "", joint: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSpeedConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSpeedConfigRequest): GetSpeedConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string speed_type */ 1:
                    message.speed_type = reader.string();
                    break;
                case /* string speed_level */ 2:
                    message.speed_level = reader.string();
                    break;
                case /* string joint */ 3:
                    message.joint = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSpeedConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string speed_type = 1; */
        if (message.speed_type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.speed_type);
        /* string speed_level = 2; */
        if (message.speed_level !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.speed_level);
        /* string joint = 3; */
        if (message.joint !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.joint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetSpeedConfigRequest
 */
export const GetSpeedConfigRequest = new GetSpeedConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSpeedConfigResponse$Type extends MessageType<GetSpeedConfigResponse> {
    constructor() {
        super("rosc.GetSpeedConfigResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "speed_config", kind: "scalar", localName: "speed_config", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "specify_speed", kind: "scalar", localName: "specify_speed", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetSpeedConfigResponse>): GetSpeedConfigResponse {
        const message = { reply: "", code: 0, speed_config: "", specify_speed: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSpeedConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSpeedConfigResponse): GetSpeedConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string speed_config */ 3:
                    message.speed_config = reader.string();
                    break;
                case /* bool specify_speed */ 4:
                    message.specify_speed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSpeedConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string speed_config = 3; */
        if (message.speed_config !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.speed_config);
        /* bool specify_speed = 4; */
        if (message.specify_speed !== false)
            writer.tag(4, WireType.Varint).bool(message.specify_speed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetSpeedConfigResponse
 */
export const GetSpeedConfigResponse = new GetSpeedConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveSpeedConfigRequest$Type extends MessageType<SaveSpeedConfigRequest> {
    constructor() {
        super("rosc.SaveSpeedConfigRequest", [
            { no: 1, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SpeedConfig },
            { no: 2, name: "speed_type", kind: "scalar", localName: "speed_type", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "specify_speed", kind: "scalar", localName: "specify_speed", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SaveSpeedConfigRequest>): SaveSpeedConfigRequest {
        const message = { data: [], speed_type: "", specify_speed: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveSpeedConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveSpeedConfigRequest): SaveSpeedConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated rosc.SpeedConfig data */ 1:
                    message.data.push(SpeedConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string speed_type */ 2:
                    message.speed_type = reader.string();
                    break;
                case /* bool specify_speed */ 3:
                    message.specify_speed = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveSpeedConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated rosc.SpeedConfig data = 1; */
        for (let i = 0; i < message.data.length; i++)
            SpeedConfig.internalBinaryWrite(message.data[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string speed_type = 2; */
        if (message.speed_type !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.speed_type);
        /* bool specify_speed = 3; */
        if (message.specify_speed !== false)
            writer.tag(3, WireType.Varint).bool(message.specify_speed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveSpeedConfigRequest
 */
export const SaveSpeedConfigRequest = new SaveSpeedConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveSpeedConfigResponse$Type extends MessageType<SaveSpeedConfigResponse> {
    constructor() {
        super("rosc.SaveSpeedConfigResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SaveSpeedConfigResponse>): SaveSpeedConfigResponse {
        const message = { reply: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveSpeedConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveSpeedConfigResponse): SaveSpeedConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveSpeedConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveSpeedConfigResponse
 */
export const SaveSpeedConfigResponse = new SaveSpeedConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSorterConfigRequest$Type extends MessageType<GetSorterConfigRequest> {
    constructor() {
        super("rosc.GetSorterConfigRequest", [
            { no: 1, name: "offset_type", kind: "scalar", localName: "offset_type", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "number", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetSorterConfigRequest>): GetSorterConfigRequest {
        const message = { offset_type: "", number: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSorterConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSorterConfigRequest): GetSorterConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string offset_type */ 1:
                    message.offset_type = reader.string();
                    break;
                case /* int32 number */ 2:
                    message.number = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSorterConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string offset_type = 1; */
        if (message.offset_type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.offset_type);
        /* int32 number = 2; */
        if (message.number !== 0)
            writer.tag(2, WireType.Varint).int32(message.number);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetSorterConfigRequest
 */
export const GetSorterConfigRequest = new GetSorterConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSorterConfigResponse$Type extends MessageType<GetSorterConfigResponse> {
    constructor() {
        super("rosc.GetSorterConfigResponse", [
            { no: 1, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "sorter_config", kind: "scalar", localName: "sorter_config", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSorterConfigResponse>): GetSorterConfigResponse {
        const message = { reply: "", code: 0, sorter_config: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSorterConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSorterConfigResponse): GetSorterConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string reply */ 1:
                    message.reply = reader.string();
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                case /* string sorter_config */ 3:
                    message.sorter_config = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSorterConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string reply = 1; */
        if (message.reply !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reply);
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        /* string sorter_config = 3; */
        if (message.sorter_config !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sorter_config);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetSorterConfigResponse
 */
export const GetSorterConfigResponse = new GetSorterConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SorterConfig$Type extends MessageType<SorterConfig> {
    constructor() {
        super("rosc.SorterConfig", [
            { no: 1, name: "attribute", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SorterConfig>): SorterConfig {
        const message = { attribute: "", value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SorterConfig>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SorterConfig): SorterConfig {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string attribute */ 1:
                    message.attribute = reader.string();
                    break;
                case /* double value */ 2:
                    message.value = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SorterConfig, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string attribute = 1; */
        if (message.attribute !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.attribute);
        /* double value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit64).double(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SorterConfig
 */
export const SorterConfig = new SorterConfig$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveSorterConfigRequest$Type extends MessageType<SaveSorterConfigRequest> {
    constructor() {
        super("rosc.SaveSorterConfigRequest", [
            { no: 1, name: "offset_type", kind: "scalar", localName: "offset_type", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "number", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "sorter_config", kind: "message", localName: "sorter_config", repeat: 1 /*RepeatType.PACKED*/, T: () => SorterConfig }
        ]);
    }
    create(value?: PartialMessage<SaveSorterConfigRequest>): SaveSorterConfigRequest {
        const message = { offset_type: "", number: 0, sorter_config: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveSorterConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveSorterConfigRequest): SaveSorterConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string offset_type */ 1:
                    message.offset_type = reader.string();
                    break;
                case /* int32 number */ 2:
                    message.number = reader.int32();
                    break;
                case /* repeated rosc.SorterConfig sorter_config */ 3:
                    message.sorter_config.push(SorterConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveSorterConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string offset_type = 1; */
        if (message.offset_type !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.offset_type);
        /* int32 number = 2; */
        if (message.number !== 0)
            writer.tag(2, WireType.Varint).int32(message.number);
        /* repeated rosc.SorterConfig sorter_config = 3; */
        for (let i = 0; i < message.sorter_config.length; i++)
            SorterConfig.internalBinaryWrite(message.sorter_config[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveSorterConfigRequest
 */
export const SaveSorterConfigRequest = new SaveSorterConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveSorterConfigResponse$Type extends MessageType<SaveSorterConfigResponse> {
    constructor() {
        super("rosc.SaveSorterConfigResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SaveSorterConfigResponse>): SaveSorterConfigResponse {
        const message = { code: 0, reply: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveSorterConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveSorterConfigResponse): SaveSorterConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string reply */ 2:
                    message.reply = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveSorterConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string reply = 2; */
        if (message.reply !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reply);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveSorterConfigResponse
 */
export const SaveSorterConfigResponse = new SaveSorterConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchMappingRequest$Type extends MessageType<SearchMappingRequest> {
    constructor() {
        super("rosc.SearchMappingRequest", [
            { no: 1, name: "cassette", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SearchMappingRequest>): SearchMappingRequest {
        const message = { cassette: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SearchMappingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchMappingRequest): SearchMappingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cassette */ 1:
                    message.cassette = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchMappingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cassette = 1; */
        if (message.cassette !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cassette);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SearchMappingRequest
 */
export const SearchMappingRequest = new SearchMappingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchMappingResponse$Type extends MessageType<SearchMappingResponse> {
    constructor() {
        super("rosc.SearchMappingResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "num", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "wafer_condition", kind: "scalar", localName: "wafer_condition", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "start_position", kind: "scalar", localName: "start_position", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "finish_position", kind: "scalar", localName: "finish_position", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "wafer_thick", kind: "scalar", localName: "wafer_thick", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<SearchMappingResponse>): SearchMappingResponse {
        const message = { code: 0, reply: "", num: 0, wafer_condition: [], start_position: 0, finish_position: 0, wafer_thick: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SearchMappingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchMappingResponse): SearchMappingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string reply */ 2:
                    message.reply = reader.string();
                    break;
                case /* int32 num */ 3:
                    message.num = reader.int32();
                    break;
                case /* repeated int32 wafer_condition */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.wafer_condition.push(reader.int32());
                    else
                        message.wafer_condition.push(reader.int32());
                    break;
                case /* double start_position */ 5:
                    message.start_position = reader.double();
                    break;
                case /* double finish_position */ 6:
                    message.finish_position = reader.double();
                    break;
                case /* repeated double wafer_thick */ 7:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.wafer_thick.push(reader.double());
                    else
                        message.wafer_thick.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchMappingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string reply = 2; */
        if (message.reply !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reply);
        /* int32 num = 3; */
        if (message.num !== 0)
            writer.tag(3, WireType.Varint).int32(message.num);
        /* repeated int32 wafer_condition = 4; */
        if (message.wafer_condition.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.wafer_condition.length; i++)
                writer.int32(message.wafer_condition[i]);
            writer.join();
        }
        /* double start_position = 5; */
        if (message.start_position !== 0)
            writer.tag(5, WireType.Bit64).double(message.start_position);
        /* double finish_position = 6; */
        if (message.finish_position !== 0)
            writer.tag(6, WireType.Bit64).double(message.finish_position);
        /* repeated double wafer_thick = 7; */
        if (message.wafer_thick.length) {
            writer.tag(7, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.wafer_thick.length; i++)
                writer.double(message.wafer_thick[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SearchMappingResponse
 */
export const SearchMappingResponse = new SearchMappingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MappingCalibrateRequest$Type extends MessageType<MappingCalibrateRequest> {
    constructor() {
        super("rosc.MappingCalibrateRequest", [
            { no: 1, name: "cassette", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MappingCalibrateRequest>): MappingCalibrateRequest {
        const message = { cassette: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MappingCalibrateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MappingCalibrateRequest): MappingCalibrateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cassette */ 1:
                    message.cassette = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MappingCalibrateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cassette = 1; */
        if (message.cassette !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cassette);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.MappingCalibrateRequest
 */
export const MappingCalibrateRequest = new MappingCalibrateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MappingCalibrateResponse$Type extends MessageType<MappingCalibrateResponse> {
    constructor() {
        super("rosc.MappingCalibrateResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MappingCalibrateResponse>): MappingCalibrateResponse {
        const message = { code: 0, reply: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MappingCalibrateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MappingCalibrateResponse): MappingCalibrateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string reply */ 2:
                    message.reply = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MappingCalibrateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string reply = 2; */
        if (message.reply !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reply);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.MappingCalibrateResponse
 */
export const MappingCalibrateResponse = new MappingCalibrateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MappingSettingItem$Type extends MessageType<MappingSettingItem> {
    constructor() {
        super("rosc.MappingSettingItem", [
            { no: 1, name: "mapping_name", kind: "scalar", localName: "mapping_name", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "mapping_values", kind: "scalar", localName: "mapping_values", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<MappingSettingItem>): MappingSettingItem {
        const message = { mapping_name: "", mapping_values: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MappingSettingItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MappingSettingItem): MappingSettingItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mapping_name */ 1:
                    message.mapping_name = reader.string();
                    break;
                case /* double mapping_values */ 2:
                    message.mapping_values = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MappingSettingItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mapping_name = 1; */
        if (message.mapping_name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mapping_name);
        /* double mapping_values = 2; */
        if (message.mapping_values !== 0)
            writer.tag(2, WireType.Bit64).double(message.mapping_values);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.MappingSettingItem
 */
export const MappingSettingItem = new MappingSettingItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MappingSettingRequest$Type extends MessageType<MappingSettingRequest> {
    constructor() {
        super("rosc.MappingSettingRequest", [
            { no: 1, name: "station", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<MappingSettingRequest>): MappingSettingRequest {
        const message = { station: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MappingSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MappingSettingRequest): MappingSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string station */ 1:
                    message.station = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MappingSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string station = 1; */
        if (message.station !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.station);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.MappingSettingRequest
 */
export const MappingSettingRequest = new MappingSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MappingSettingResponse$Type extends MessageType<MappingSettingResponse> {
    constructor() {
        super("rosc.MappingSettingResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "mapping_name", kind: "scalar", localName: "mapping_name", repeat: 2 /*RepeatType.UNPACKED*/, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "mapping_value", kind: "scalar", localName: "mapping_value", repeat: 1 /*RepeatType.PACKED*/, T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<MappingSettingResponse>): MappingSettingResponse {
        const message = { code: 0, reply: "", mapping_name: [], mapping_value: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MappingSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MappingSettingResponse): MappingSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string reply */ 2:
                    message.reply = reader.string();
                    break;
                case /* repeated string mapping_name */ 3:
                    message.mapping_name.push(reader.string());
                    break;
                case /* repeated double mapping_value */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.mapping_value.push(reader.double());
                    else
                        message.mapping_value.push(reader.double());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MappingSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string reply = 2; */
        if (message.reply !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reply);
        /* repeated string mapping_name = 3; */
        for (let i = 0; i < message.mapping_name.length; i++)
            writer.tag(3, WireType.LengthDelimited).string(message.mapping_name[i]);
        /* repeated double mapping_value = 4; */
        if (message.mapping_value.length) {
            writer.tag(4, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.mapping_value.length; i++)
                writer.double(message.mapping_value[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.MappingSettingResponse
 */
export const MappingSettingResponse = new MappingSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveMappingSettingRequest$Type extends MessageType<SaveMappingSettingRequest> {
    constructor() {
        super("rosc.SaveMappingSettingRequest", [
            { no: 1, name: "station", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "mapping_setting", kind: "message", localName: "mapping_setting", repeat: 1 /*RepeatType.PACKED*/, T: () => MappingSettingItem }
        ]);
    }
    create(value?: PartialMessage<SaveMappingSettingRequest>): SaveMappingSettingRequest {
        const message = { station: "", mapping_setting: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveMappingSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveMappingSettingRequest): SaveMappingSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string station */ 1:
                    message.station = reader.string();
                    break;
                case /* repeated rosc.MappingSettingItem mapping_setting */ 2:
                    message.mapping_setting.push(MappingSettingItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveMappingSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string station = 1; */
        if (message.station !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.station);
        /* repeated rosc.MappingSettingItem mapping_setting = 2; */
        for (let i = 0; i < message.mapping_setting.length; i++)
            MappingSettingItem.internalBinaryWrite(message.mapping_setting[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveMappingSettingRequest
 */
export const SaveMappingSettingRequest = new SaveMappingSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveMappingSettingResponse$Type extends MessageType<SaveMappingSettingResponse> {
    constructor() {
        super("rosc.SaveMappingSettingResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SaveMappingSettingResponse>): SaveMappingSettingResponse {
        const message = { code: 0, reply: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveMappingSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveMappingSettingResponse): SaveMappingSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string reply */ 2:
                    message.reply = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveMappingSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string reply = 2; */
        if (message.reply !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reply);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveMappingSettingResponse
 */
export const SaveMappingSettingResponse = new SaveMappingSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetSolenoidRequest$Type extends MessageType<SetSolenoidRequest> {
    constructor() {
        super("rosc.SetSolenoidRequest", [
            { no: 1, name: "arm", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "value", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SetSolenoidRequest>): SetSolenoidRequest {
        const message = { arm: 0, value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetSolenoidRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetSolenoidRequest): SetSolenoidRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 arm */ 1:
                    message.arm = reader.int32();
                    break;
                case /* int32 value */ 2:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetSolenoidRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 arm = 1; */
        if (message.arm !== 0)
            writer.tag(1, WireType.Varint).int32(message.arm);
        /* int32 value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SetSolenoidRequest
 */
export const SetSolenoidRequest = new SetSolenoidRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetSolenoidResponse$Type extends MessageType<SetSolenoidResponse> {
    constructor() {
        super("rosc.SetSolenoidResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "reply", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetSolenoidResponse>): SetSolenoidResponse {
        const message = { code: 0, reply: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetSolenoidResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetSolenoidResponse): SetSolenoidResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string reply */ 2:
                    message.reply = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetSolenoidResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string reply = 2; */
        if (message.reply !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.reply);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SetSolenoidResponse
 */
export const SetSolenoidResponse = new SetSolenoidResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSolenoidRequest$Type extends MessageType<GetSolenoidRequest> {
    constructor() {
        super("rosc.GetSolenoidRequest", []);
    }
    create(value?: PartialMessage<GetSolenoidRequest>): GetSolenoidRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSolenoidRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSolenoidRequest): GetSolenoidRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetSolenoidRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetSolenoidRequest
 */
export const GetSolenoidRequest = new GetSolenoidRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSolenoidResponse$Type extends MessageType<GetSolenoidResponse> {
    constructor() {
        super("rosc.GetSolenoidResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "solenoid_r1", kind: "scalar", localName: "solenoid_r1", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "solenoid_r2", kind: "scalar", localName: "solenoid_r2", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetSolenoidResponse>): GetSolenoidResponse {
        const message = { code: 0, solenoid_r1: 0, solenoid_r2: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSolenoidResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSolenoidResponse): GetSolenoidResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* int32 solenoid_r1 */ 2:
                    message.solenoid_r1 = reader.int32();
                    break;
                case /* int32 solenoid_r2 */ 3:
                    message.solenoid_r2 = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSolenoidResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* int32 solenoid_r1 = 2; */
        if (message.solenoid_r1 !== 0)
            writer.tag(2, WireType.Varint).int32(message.solenoid_r1);
        /* int32 solenoid_r2 = 3; */
        if (message.solenoid_r2 !== 0)
            writer.tag(3, WireType.Varint).int32(message.solenoid_r2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetSolenoidResponse
 */
export const GetSolenoidResponse = new GetSolenoidResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEnableMappingRequest$Type extends MessageType<GetEnableMappingRequest> {
    constructor() {
        super("rosc.GetEnableMappingRequest", []);
    }
    create(value?: PartialMessage<GetEnableMappingRequest>): GetEnableMappingRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetEnableMappingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEnableMappingRequest): GetEnableMappingRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetEnableMappingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetEnableMappingRequest
 */
export const GetEnableMappingRequest = new GetEnableMappingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEnableMappingResponse$Type extends MessageType<GetEnableMappingResponse> {
    constructor() {
        super("rosc.GetEnableMappingResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "enable", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetEnableMappingResponse>): GetEnableMappingResponse {
        const message = { code: 0, enable: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetEnableMappingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEnableMappingResponse): GetEnableMappingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* int32 enable */ 2:
                    message.enable = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEnableMappingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* int32 enable = 2; */
        if (message.enable !== 0)
            writer.tag(2, WireType.Varint).int32(message.enable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetEnableMappingResponse
 */
export const GetEnableMappingResponse = new GetEnableMappingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveEnableMappingRequest$Type extends MessageType<SaveEnableMappingRequest> {
    constructor() {
        super("rosc.SaveEnableMappingRequest", [
            { no: 1, name: "enable", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SaveEnableMappingRequest>): SaveEnableMappingRequest {
        const message = { enable: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveEnableMappingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveEnableMappingRequest): SaveEnableMappingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 enable */ 1:
                    message.enable = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveEnableMappingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 enable = 1; */
        if (message.enable !== 0)
            writer.tag(1, WireType.Varint).int32(message.enable);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveEnableMappingRequest
 */
export const SaveEnableMappingRequest = new SaveEnableMappingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveEnableMappingResponse$Type extends MessageType<SaveEnableMappingResponse> {
    constructor() {
        super("rosc.SaveEnableMappingResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SaveEnableMappingResponse>): SaveEnableMappingResponse {
        const message = { code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveEnableMappingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveEnableMappingResponse): SaveEnableMappingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveEnableMappingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveEnableMappingResponse
 */
export const SaveEnableMappingResponse = new SaveEnableMappingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedifyControllerIPRequest$Type extends MessageType<RedifyControllerIPRequest> {
    constructor() {
        super("rosc.RedifyControllerIPRequest", [
            { no: 1, name: "addresses", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "gateway4", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<RedifyControllerIPRequest>): RedifyControllerIPRequest {
        const message = { addresses: "", gateway4: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RedifyControllerIPRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedifyControllerIPRequest): RedifyControllerIPRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string addresses */ 1:
                    message.addresses = reader.string();
                    break;
                case /* string gateway4 */ 2:
                    message.gateway4 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedifyControllerIPRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string addresses = 1; */
        if (message.addresses !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.addresses);
        /* string gateway4 = 2; */
        if (message.gateway4 !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.gateway4);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.RedifyControllerIPRequest
 */
export const RedifyControllerIPRequest = new RedifyControllerIPRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedifyControllerIPResponse$Type extends MessageType<RedifyControllerIPResponse> {
    constructor() {
        super("rosc.RedifyControllerIPResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RedifyControllerIPResponse>): RedifyControllerIPResponse {
        const message = { code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RedifyControllerIPResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedifyControllerIPResponse): RedifyControllerIPResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedifyControllerIPResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.RedifyControllerIPResponse
 */
export const RedifyControllerIPResponse = new RedifyControllerIPResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetServoEncodeRequest$Type extends MessageType<GetServoEncodeRequest> {
    constructor() {
        super("rosc.GetServoEncodeRequest", []);
    }
    create(value?: PartialMessage<GetServoEncodeRequest>): GetServoEncodeRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetServoEncodeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetServoEncodeRequest): GetServoEncodeRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetServoEncodeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetServoEncodeRequest
 */
export const GetServoEncodeRequest = new GetServoEncodeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetServoEncodeResponse$Type extends MessageType<GetServoEncodeResponse> {
    constructor() {
        super("rosc.GetServoEncodeResponse", [
            { no: 1, name: "encode", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetServoEncodeResponse>): GetServoEncodeResponse {
        const message = { encode: [], code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetServoEncodeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetServoEncodeResponse): GetServoEncodeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 encode */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.encode.push(reader.int32());
                    else
                        message.encode.push(reader.int32());
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetServoEncodeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 encode = 1; */
        if (message.encode.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.encode.length; i++)
                writer.int32(message.encode[i]);
            writer.join();
        }
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetServoEncodeResponse
 */
export const GetServoEncodeResponse = new GetServoEncodeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePointFileRequest$Type extends MessageType<UpdatePointFileRequest> {
    constructor() {
        super("rosc.UpdatePointFileRequest", [
            { no: 1, name: "data", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePointFileRequest>): UpdatePointFileRequest {
        const message = { data: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatePointFileRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePointFileRequest): UpdatePointFileRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string data */ 1:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePointFileRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string data = 1; */
        if (message.data !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.UpdatePointFileRequest
 */
export const UpdatePointFileRequest = new UpdatePointFileRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdatePointFileResponse$Type extends MessageType<UpdatePointFileResponse> {
    constructor() {
        super("rosc.UpdatePointFileResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdatePointFileResponse>): UpdatePointFileResponse {
        const message = { code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdatePointFileResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdatePointFileResponse): UpdatePointFileResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdatePointFileResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.UpdatePointFileResponse
 */
export const UpdatePointFileResponse = new UpdatePointFileResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAWCConfigRequest$Type extends MessageType<GetAWCConfigRequest> {
    constructor() {
        super("rosc.GetAWCConfigRequest", [
            { no: 1, name: "stage", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetAWCConfigRequest>): GetAWCConfigRequest {
        const message = { stage: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAWCConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAWCConfigRequest): GetAWCConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stage */ 1:
                    message.stage = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAWCConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stage = 1; */
        if (message.stage !== 0)
            writer.tag(1, WireType.Varint).int32(message.stage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetAWCConfigRequest
 */
export const GetAWCConfigRequest = new GetAWCConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAWCConfigResponse$Type extends MessageType<GetAWCConfigResponse> {
    constructor() {
        super("rosc.GetAWCConfigResponse", [
            { no: 1, name: "enable_awc", kind: "scalar", localName: "enable_awc", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "sensor_num", kind: "scalar", localName: "sensor_num", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "sensor_io_serial1", kind: "scalar", localName: "sensor_io_serial1", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "sensor_io_serial2", kind: "scalar", localName: "sensor_io_serial2", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "sensor_pos1", kind: "scalar", localName: "sensor_pos1", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "sensor_pos2", kind: "scalar", localName: "sensor_pos2", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetAWCConfigResponse>): GetAWCConfigResponse {
        const message = { enable_awc: false, sensor_num: 0, sensor_io_serial1: 0, sensor_io_serial2: 0, sensor_pos1: "", sensor_pos2: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAWCConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAWCConfigResponse): GetAWCConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool enable_awc */ 1:
                    message.enable_awc = reader.bool();
                    break;
                case /* int32 sensor_num */ 2:
                    message.sensor_num = reader.int32();
                    break;
                case /* int32 sensor_io_serial1 */ 3:
                    message.sensor_io_serial1 = reader.int32();
                    break;
                case /* int32 sensor_io_serial2 */ 4:
                    message.sensor_io_serial2 = reader.int32();
                    break;
                case /* string sensor_pos1 */ 5:
                    message.sensor_pos1 = reader.string();
                    break;
                case /* string sensor_pos2 */ 6:
                    message.sensor_pos2 = reader.string();
                    break;
                case /* int32 code */ 7:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAWCConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool enable_awc = 1; */
        if (message.enable_awc !== false)
            writer.tag(1, WireType.Varint).bool(message.enable_awc);
        /* int32 sensor_num = 2; */
        if (message.sensor_num !== 0)
            writer.tag(2, WireType.Varint).int32(message.sensor_num);
        /* int32 sensor_io_serial1 = 3; */
        if (message.sensor_io_serial1 !== 0)
            writer.tag(3, WireType.Varint).int32(message.sensor_io_serial1);
        /* int32 sensor_io_serial2 = 4; */
        if (message.sensor_io_serial2 !== 0)
            writer.tag(4, WireType.Varint).int32(message.sensor_io_serial2);
        /* string sensor_pos1 = 5; */
        if (message.sensor_pos1 !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.sensor_pos1);
        /* string sensor_pos2 = 6; */
        if (message.sensor_pos2 !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sensor_pos2);
        /* int32 code = 7; */
        if (message.code !== 0)
            writer.tag(7, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetAWCConfigResponse
 */
export const GetAWCConfigResponse = new GetAWCConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveAWCConfigRequest$Type extends MessageType<SaveAWCConfigRequest> {
    constructor() {
        super("rosc.SaveAWCConfigRequest", [
            { no: 1, name: "stage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "enable_awc", kind: "scalar", localName: "enable_awc", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "sensor_num", kind: "scalar", localName: "sensor_num", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "sensor_io_serial1", kind: "scalar", localName: "sensor_io_serial1", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "sensor_io_serial2", kind: "scalar", localName: "sensor_io_serial2", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "sensor_pos1", kind: "scalar", localName: "sensor_pos1", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "sensor_pos2", kind: "scalar", localName: "sensor_pos2", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SaveAWCConfigRequest>): SaveAWCConfigRequest {
        const message = { stage: 0, enable_awc: false, sensor_num: 0, sensor_io_serial1: 0, sensor_io_serial2: 0, sensor_pos1: "", sensor_pos2: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveAWCConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveAWCConfigRequest): SaveAWCConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stage */ 1:
                    message.stage = reader.int32();
                    break;
                case /* bool enable_awc */ 2:
                    message.enable_awc = reader.bool();
                    break;
                case /* int32 sensor_num */ 3:
                    message.sensor_num = reader.int32();
                    break;
                case /* int32 sensor_io_serial1 */ 4:
                    message.sensor_io_serial1 = reader.int32();
                    break;
                case /* int32 sensor_io_serial2 */ 5:
                    message.sensor_io_serial2 = reader.int32();
                    break;
                case /* string sensor_pos1 */ 6:
                    message.sensor_pos1 = reader.string();
                    break;
                case /* string sensor_pos2 */ 7:
                    message.sensor_pos2 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveAWCConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stage = 1; */
        if (message.stage !== 0)
            writer.tag(1, WireType.Varint).int32(message.stage);
        /* bool enable_awc = 2; */
        if (message.enable_awc !== false)
            writer.tag(2, WireType.Varint).bool(message.enable_awc);
        /* int32 sensor_num = 3; */
        if (message.sensor_num !== 0)
            writer.tag(3, WireType.Varint).int32(message.sensor_num);
        /* int32 sensor_io_serial1 = 4; */
        if (message.sensor_io_serial1 !== 0)
            writer.tag(4, WireType.Varint).int32(message.sensor_io_serial1);
        /* int32 sensor_io_serial2 = 5; */
        if (message.sensor_io_serial2 !== 0)
            writer.tag(5, WireType.Varint).int32(message.sensor_io_serial2);
        /* string sensor_pos1 = 6; */
        if (message.sensor_pos1 !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.sensor_pos1);
        /* string sensor_pos2 = 7; */
        if (message.sensor_pos2 !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.sensor_pos2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveAWCConfigRequest
 */
export const SaveAWCConfigRequest = new SaveAWCConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveAWCConfigResponse$Type extends MessageType<SaveAWCConfigResponse> {
    constructor() {
        super("rosc.SaveAWCConfigResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SaveAWCConfigResponse>): SaveAWCConfigResponse {
        const message = { code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveAWCConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveAWCConfigResponse): SaveAWCConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveAWCConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveAWCConfigResponse
 */
export const SaveAWCConfigResponse = new SaveAWCConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrateAWCSensorRequest$Type extends MessageType<CalibrateAWCSensorRequest> {
    constructor() {
        super("rosc.CalibrateAWCSensorRequest", [
            { no: 1, name: "stage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "arm", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CalibrateAWCSensorRequest>): CalibrateAWCSensorRequest {
        const message = { stage: 0, arm: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CalibrateAWCSensorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrateAWCSensorRequest): CalibrateAWCSensorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stage */ 1:
                    message.stage = reader.int32();
                    break;
                case /* int32 arm */ 2:
                    message.arm = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalibrateAWCSensorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stage = 1; */
        if (message.stage !== 0)
            writer.tag(1, WireType.Varint).int32(message.stage);
        /* int32 arm = 2; */
        if (message.arm !== 0)
            writer.tag(2, WireType.Varint).int32(message.arm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.CalibrateAWCSensorRequest
 */
export const CalibrateAWCSensorRequest = new CalibrateAWCSensorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrateAWCSensorResponse$Type extends MessageType<CalibrateAWCSensorResponse> {
    constructor() {
        super("rosc.CalibrateAWCSensorResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CalibrateAWCSensorResponse>): CalibrateAWCSensorResponse {
        const message = { code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CalibrateAWCSensorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrateAWCSensorResponse): CalibrateAWCSensorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalibrateAWCSensorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.CalibrateAWCSensorResponse
 */
export const CalibrateAWCSensorResponse = new CalibrateAWCSensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIOInterlockSettingRequest$Type extends MessageType<GetIOInterlockSettingRequest> {
    constructor() {
        super("rosc.GetIOInterlockSettingRequest", [
            { no: 1, name: "stage", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetIOInterlockSettingRequest>): GetIOInterlockSettingRequest {
        const message = { stage: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIOInterlockSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIOInterlockSettingRequest): GetIOInterlockSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stage */ 1:
                    message.stage = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIOInterlockSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stage = 1; */
        if (message.stage !== 0)
            writer.tag(1, WireType.Varint).int32(message.stage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetIOInterlockSettingRequest
 */
export const GetIOInterlockSettingRequest = new GetIOInterlockSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetIOInterlockSettingResponse$Type extends MessageType<GetIOInterlockSettingResponse> {
    constructor() {
        super("rosc.GetIOInterlockSettingResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "enable_extend_sensor", kind: "scalar", localName: "enable_extend_sensor", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "wafer_sensor", kind: "scalar", localName: "wafer_sensor", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "arm_at_home_sensor", kind: "scalar", localName: "arm_at_home_sensor", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "enable_extend_state", kind: "scalar", localName: "enable_extend_state", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "arm_at_home_state", kind: "scalar", localName: "arm_at_home_state", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "wafer_sensor_state", kind: "scalar", localName: "wafer_sensor_state", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "tz_state", kind: "scalar", localName: "tz_state", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetIOInterlockSettingResponse>): GetIOInterlockSettingResponse {
        const message = { code: 0, enable_extend_sensor: 0, wafer_sensor: 0, arm_at_home_sensor: 0, enable_extend_state: "", arm_at_home_state: "", wafer_sensor_state: "", tz_state: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetIOInterlockSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetIOInterlockSettingResponse): GetIOInterlockSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                case /* int32 enable_extend_sensor */ 2:
                    message.enable_extend_sensor = reader.int32();
                    break;
                case /* int32 wafer_sensor */ 3:
                    message.wafer_sensor = reader.int32();
                    break;
                case /* int32 arm_at_home_sensor */ 4:
                    message.arm_at_home_sensor = reader.int32();
                    break;
                case /* string enable_extend_state */ 5:
                    message.enable_extend_state = reader.string();
                    break;
                case /* string arm_at_home_state */ 6:
                    message.arm_at_home_state = reader.string();
                    break;
                case /* string wafer_sensor_state */ 7:
                    message.wafer_sensor_state = reader.string();
                    break;
                case /* string tz_state */ 8:
                    message.tz_state = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetIOInterlockSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* int32 enable_extend_sensor = 2; */
        if (message.enable_extend_sensor !== 0)
            writer.tag(2, WireType.Varint).int32(message.enable_extend_sensor);
        /* int32 wafer_sensor = 3; */
        if (message.wafer_sensor !== 0)
            writer.tag(3, WireType.Varint).int32(message.wafer_sensor);
        /* int32 arm_at_home_sensor = 4; */
        if (message.arm_at_home_sensor !== 0)
            writer.tag(4, WireType.Varint).int32(message.arm_at_home_sensor);
        /* string enable_extend_state = 5; */
        if (message.enable_extend_state !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.enable_extend_state);
        /* string arm_at_home_state = 6; */
        if (message.arm_at_home_state !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.arm_at_home_state);
        /* string wafer_sensor_state = 7; */
        if (message.wafer_sensor_state !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.wafer_sensor_state);
        /* string tz_state = 8; */
        if (message.tz_state !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.tz_state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetIOInterlockSettingResponse
 */
export const GetIOInterlockSettingResponse = new GetIOInterlockSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveIOInterlockSettingRequest$Type extends MessageType<SaveIOInterlockSettingRequest> {
    constructor() {
        super("rosc.SaveIOInterlockSettingRequest", [
            { no: 1, name: "stage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "enable_extend_sensor", kind: "scalar", localName: "enable_extend_sensor", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "wafer_sensor", kind: "scalar", localName: "wafer_sensor", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "arm_at_home_sensor", kind: "scalar", localName: "arm_at_home_sensor", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "enable_extend_state", kind: "scalar", localName: "enable_extend_state", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "arm_at_home_state", kind: "scalar", localName: "arm_at_home_state", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "wafer_sensor_state", kind: "scalar", localName: "wafer_sensor_state", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "tz_state", kind: "scalar", localName: "tz_state", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SaveIOInterlockSettingRequest>): SaveIOInterlockSettingRequest {
        const message = { stage: 0, enable_extend_sensor: 0, wafer_sensor: 0, arm_at_home_sensor: 0, enable_extend_state: "", arm_at_home_state: "", wafer_sensor_state: "", tz_state: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveIOInterlockSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveIOInterlockSettingRequest): SaveIOInterlockSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stage */ 1:
                    message.stage = reader.int32();
                    break;
                case /* int32 enable_extend_sensor */ 2:
                    message.enable_extend_sensor = reader.int32();
                    break;
                case /* int32 wafer_sensor */ 3:
                    message.wafer_sensor = reader.int32();
                    break;
                case /* int32 arm_at_home_sensor */ 4:
                    message.arm_at_home_sensor = reader.int32();
                    break;
                case /* string enable_extend_state */ 5:
                    message.enable_extend_state = reader.string();
                    break;
                case /* string arm_at_home_state */ 6:
                    message.arm_at_home_state = reader.string();
                    break;
                case /* string wafer_sensor_state */ 7:
                    message.wafer_sensor_state = reader.string();
                    break;
                case /* string tz_state */ 8:
                    message.tz_state = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveIOInterlockSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stage = 1; */
        if (message.stage !== 0)
            writer.tag(1, WireType.Varint).int32(message.stage);
        /* int32 enable_extend_sensor = 2; */
        if (message.enable_extend_sensor !== 0)
            writer.tag(2, WireType.Varint).int32(message.enable_extend_sensor);
        /* int32 wafer_sensor = 3; */
        if (message.wafer_sensor !== 0)
            writer.tag(3, WireType.Varint).int32(message.wafer_sensor);
        /* int32 arm_at_home_sensor = 4; */
        if (message.arm_at_home_sensor !== 0)
            writer.tag(4, WireType.Varint).int32(message.arm_at_home_sensor);
        /* string enable_extend_state = 5; */
        if (message.enable_extend_state !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.enable_extend_state);
        /* string arm_at_home_state = 6; */
        if (message.arm_at_home_state !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.arm_at_home_state);
        /* string wafer_sensor_state = 7; */
        if (message.wafer_sensor_state !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.wafer_sensor_state);
        /* string tz_state = 8; */
        if (message.tz_state !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.tz_state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveIOInterlockSettingRequest
 */
export const SaveIOInterlockSettingRequest = new SaveIOInterlockSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveIOInterlockSettingResponse$Type extends MessageType<SaveIOInterlockSettingResponse> {
    constructor() {
        super("rosc.SaveIOInterlockSettingResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SaveIOInterlockSettingResponse>): SaveIOInterlockSettingResponse {
        const message = { code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveIOInterlockSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveIOInterlockSettingResponse): SaveIOInterlockSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveIOInterlockSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveIOInterlockSettingResponse
 */
export const SaveIOInterlockSettingResponse = new SaveIOInterlockSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrateWaferSensorRequest$Type extends MessageType<CalibrateWaferSensorRequest> {
    constructor() {
        super("rosc.CalibrateWaferSensorRequest", [
            { no: 1, name: "stage", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CalibrateWaferSensorRequest>): CalibrateWaferSensorRequest {
        const message = { stage: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CalibrateWaferSensorRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrateWaferSensorRequest): CalibrateWaferSensorRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stage */ 1:
                    message.stage = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalibrateWaferSensorRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stage = 1; */
        if (message.stage !== 0)
            writer.tag(1, WireType.Varint).int32(message.stage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.CalibrateWaferSensorRequest
 */
export const CalibrateWaferSensorRequest = new CalibrateWaferSensorRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrateWaferSensorResponse$Type extends MessageType<CalibrateWaferSensorResponse> {
    constructor() {
        super("rosc.CalibrateWaferSensorResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CalibrateWaferSensorResponse>): CalibrateWaferSensorResponse {
        const message = { code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CalibrateWaferSensorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrateWaferSensorResponse): CalibrateWaferSensorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalibrateWaferSensorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.CalibrateWaferSensorResponse
 */
export const CalibrateWaferSensorResponse = new CalibrateWaferSensorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindZeroRequest$Type extends MessageType<FindZeroRequest> {
    constructor() {
        super("rosc.FindZeroRequest", []);
    }
    create(value?: PartialMessage<FindZeroRequest>): FindZeroRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FindZeroRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindZeroRequest): FindZeroRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: FindZeroRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.FindZeroRequest
 */
export const FindZeroRequest = new FindZeroRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FindZeroResponse$Type extends MessageType<FindZeroResponse> {
    constructor() {
        super("rosc.FindZeroResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FindZeroResponse>): FindZeroResponse {
        const message = { code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FindZeroResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FindZeroResponse): FindZeroResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FindZeroResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.FindZeroResponse
 */
export const FindZeroResponse = new FindZeroResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StageSettingItem$Type extends MessageType<StageSettingItem> {
    constructor() {
        super("rosc.StageSettingItem", [
            { no: 1, name: "attribute", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "value", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<StageSettingItem>): StageSettingItem {
        const message = { attribute: "", value: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StageSettingItem>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StageSettingItem): StageSettingItem {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string attribute */ 1:
                    message.attribute = reader.string();
                    break;
                case /* double value */ 2:
                    message.value = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StageSettingItem, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string attribute = 1; */
        if (message.attribute !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.attribute);
        /* double value = 2; */
        if (message.value !== 0)
            writer.tag(2, WireType.Bit64).double(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.StageSettingItem
 */
export const StageSettingItem = new StageSettingItem$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStageSettingRequest$Type extends MessageType<GetStageSettingRequest> {
    constructor() {
        super("rosc.GetStageSettingRequest", [
            { no: 1, name: "stage", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetStageSettingRequest>): GetStageSettingRequest {
        const message = { stage: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetStageSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStageSettingRequest): GetStageSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stage */ 1:
                    message.stage = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStageSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stage = 1; */
        if (message.stage !== 0)
            writer.tag(1, WireType.Varint).int32(message.stage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetStageSettingRequest
 */
export const GetStageSettingRequest = new GetStageSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetStageSettingResponse$Type extends MessageType<GetStageSettingResponse> {
    constructor() {
        super("rosc.GetStageSettingResponse", [
            { no: 1, name: "setting_items", kind: "message", localName: "setting_items", repeat: 1 /*RepeatType.PACKED*/, T: () => StageSettingItem },
            { no: 2, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetStageSettingResponse>): GetStageSettingResponse {
        const message = { setting_items: [], code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetStageSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetStageSettingResponse): GetStageSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated rosc.StageSettingItem setting_items */ 1:
                    message.setting_items.push(StageSettingItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 code */ 2:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetStageSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated rosc.StageSettingItem setting_items = 1; */
        for (let i = 0; i < message.setting_items.length; i++)
            StageSettingItem.internalBinaryWrite(message.setting_items[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 code = 2; */
        if (message.code !== 0)
            writer.tag(2, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.GetStageSettingResponse
 */
export const GetStageSettingResponse = new GetStageSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveStageSettingRequest$Type extends MessageType<SaveStageSettingRequest> {
    constructor() {
        super("rosc.SaveStageSettingRequest", [
            { no: 1, name: "stage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "setting_items", kind: "message", localName: "setting_items", repeat: 1 /*RepeatType.PACKED*/, T: () => StageSettingItem }
        ]);
    }
    create(value?: PartialMessage<SaveStageSettingRequest>): SaveStageSettingRequest {
        const message = { stage: 0, setting_items: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveStageSettingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveStageSettingRequest): SaveStageSettingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 stage */ 1:
                    message.stage = reader.int32();
                    break;
                case /* repeated rosc.StageSettingItem setting_items */ 2:
                    message.setting_items.push(StageSettingItem.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveStageSettingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 stage = 1; */
        if (message.stage !== 0)
            writer.tag(1, WireType.Varint).int32(message.stage);
        /* repeated rosc.StageSettingItem setting_items = 2; */
        for (let i = 0; i < message.setting_items.length; i++)
            StageSettingItem.internalBinaryWrite(message.setting_items[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveStageSettingRequest
 */
export const SaveStageSettingRequest = new SaveStageSettingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SaveStageSettingResponse$Type extends MessageType<SaveStageSettingResponse> {
    constructor() {
        super("rosc.SaveStageSettingResponse", [
            { no: 1, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SaveStageSettingResponse>): SaveStageSettingResponse {
        const message = { code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SaveStageSettingResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SaveStageSettingResponse): SaveStageSettingResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 code */ 1:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SaveStageSettingResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SaveStageSettingResponse
 */
export const SaveStageSettingResponse = new SaveStageSettingResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRunningModeRequest$Type extends MessageType<SetRunningModeRequest> {
    constructor() {
        super("rosc.SetRunningModeRequest", [
            { no: 1, name: "mode", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetRunningModeRequest>): SetRunningModeRequest {
        const message = { mode: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetRunningModeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRunningModeRequest): SetRunningModeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string mode */ 1:
                    message.mode = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetRunningModeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string mode = 1; */
        if (message.mode !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.mode);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SetRunningModeRequest
 */
export const SetRunningModeRequest = new SetRunningModeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetRunningModeResponse$Type extends MessageType<SetRunningModeResponse> {
    constructor() {
        super("rosc.SetRunningModeResponse", []);
    }
    create(value?: PartialMessage<SetRunningModeResponse>): SetRunningModeResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SetRunningModeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetRunningModeResponse): SetRunningModeResponse {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SetRunningModeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.SetRunningModeResponse
 */
export const SetRunningModeResponse = new SetRunningModeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrateRobotParamRequest$Type extends MessageType<CalibrateRobotParamRequest> {
    constructor() {
        super("rosc.CalibrateRobotParamRequest", []);
    }
    create(value?: PartialMessage<CalibrateRobotParamRequest>): CalibrateRobotParamRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CalibrateRobotParamRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrateRobotParamRequest): CalibrateRobotParamRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: CalibrateRobotParamRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.CalibrateRobotParamRequest
 */
export const CalibrateRobotParamRequest = new CalibrateRobotParamRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CalibrateRobotParamResponse$Type extends MessageType<CalibrateRobotParamResponse> {
    constructor() {
        super("rosc.CalibrateRobotParamResponse", [
            { no: 1, name: "result", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "code", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CalibrateRobotParamResponse>): CalibrateRobotParamResponse {
        const message = { result: 0, message: "", code: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CalibrateRobotParamResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CalibrateRobotParamResponse): CalibrateRobotParamResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 result */ 1:
                    message.result = reader.int32();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* int32 code */ 3:
                    message.code = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CalibrateRobotParamResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 result = 1; */
        if (message.result !== 0)
            writer.tag(1, WireType.Varint).int32(message.result);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* int32 code = 3; */
        if (message.code !== 0)
            writer.tag(3, WireType.Varint).int32(message.code);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message rosc.CalibrateRobotParamResponse
 */
export const CalibrateRobotParamResponse = new CalibrateRobotParamResponse$Type();
/**
 * @generated ServiceType for protobuf service rosc.RobotGrpcService
 */
export const RobotGrpcService = new ServiceType("rosc.RobotGrpcService", [
    { name: "Ping", options: {}, I: Empty, O: PingResponse },
    { name: "PowerOn", options: {}, I: Empty, O: PowerOnResponse },
    { name: "PowerOff", options: {}, I: Empty, O: PowerOffResponse },
    { name: "ClearError", options: {}, I: Empty, O: ClearErrorResponse },
    { name: "TeachStreamStartGetJoints", serverStreaming: true, options: {}, I: Empty, O: TeachStreamStartGetJointsResponse },
    { name: "TeachStreamStopGetJoints", options: {}, I: Empty, O: TeachStreamStopGetJointsResponse },
    { name: "TeachBoardStartStatusStream", serverStreaming: true, options: {}, I: Empty, O: TeachBoardStartStatusStreamResponse },
    { name: "TeachBoardStopStatusStream", options: {}, I: Empty, O: TeachBoardStopStatusStreamResponse },
    { name: "EmergencyStop", options: {}, I: EmergencyStopRequest, O: EmergencyStopResponse },
    { name: "EmergencyRecover", options: {}, I: EmergencyRecoverRequest, O: EmergencyRecoverResponse },
    { name: "TeachJogStart", options: {}, I: TeachJogStartRequest, O: TeachJogStartResponse },
    { name: "TeachJogStop", options: {}, I: TeachJogStopRequest, O: TeachJogStopResponse },
    { name: "TeachMoveStep", options: {}, I: TeachMoveStepRequest, O: TeachMoveStepResponse },
    { name: "TeachSavePosition", options: {}, I: TeachSavePositionRequest, O: TeachSavePositionResponse },
    { name: "TeachSetVelocity", options: {}, I: TeachSetVelocityRequest, O: TeachSetVelocityResponse },
    { name: "TeachGetVelocity", options: {}, I: TeachGetVelocityRequest, O: TeachGetVelocityResponse },
    { name: "TeachMove", options: {}, I: TeachMoveRequest, O: TeachMoveResponse },
    { name: "GetJogVelocity", options: {}, I: Empty, O: JogVelocityResponse },
    { name: "SetJogVelocityLevel", options: {}, I: SetJogVelocityLevelRequest, O: JogVelocityResponse },
    { name: "GetRobotSetting", options: {}, I: RobotSettingRequest, O: RobotSettingResponse },
    { name: "SaveJointSetting", options: {}, I: SaveJointSettingRequest, O: SaveJointSettingResponse },
    { name: "SaveIOSetting", options: {}, I: SaveIOSettingRequest, O: SaveIOSettingResponse },
    { name: "GetJointSetting", options: {}, I: Empty, O: GetJointSettingResponse },
    { name: "GetDeviceSetting", options: {}, I: Empty, O: GetDeviceSettingResponse },
    { name: "GetIOSetting", options: {}, I: Empty, O: GetIOSettingResponse },
    { name: "GetSpeedConfig", options: {}, I: GetSpeedConfigRequest, O: GetSpeedConfigResponse },
    { name: "SaveSpeedConfig", options: {}, I: SaveSpeedConfigRequest, O: SaveSpeedConfigResponse },
    { name: "GetSorterConfig", options: {}, I: GetSorterConfigRequest, O: GetSorterConfigResponse },
    { name: "SaveSorterConfig", options: {}, I: SaveSorterConfigRequest, O: SaveSorterConfigResponse },
    { name: "DeletePoint", options: {}, I: DeletePointRequest, O: DeletePointResponse },
    { name: "GetAllPointNames", options: {}, I: GetAllPointNamesRequest, O: GetAllPointNamesResponse },
    { name: "DownloadPointFile", serverStreaming: true, options: {}, I: DownloadPointFileRequest, O: DownloadPointFileResponse },
    { name: "GoTeachJoint", options: {}, I: GoTeachJointRequest, O: GoTeachJointResponse },
    { name: "TeachInstruction", options: {}, I: TeachInstructionRequest, O: TeachInstructionResponse },
    { name: "OperateWafer", options: {}, I: OperateWaferRequest, O: OperateWaferResponse },
    { name: "DebugWafer", options: {}, I: DebugWaferRequest, O: DebugWaferResponse },
    { name: "GetPutWafer", options: {}, I: GetPutWaferRequest, O: GetPutWaferResponse },
    { name: "GetPutWaferStop", options: {}, I: GetPutWaferStopRequest, O: GetPutWaferStopResponse },
    { name: "SetIOOutputState", options: {}, I: SetIOOutputStateRequest, O: SetIOOutputStateResponse },
    { name: "GetIOOutputState", serverStreaming: true, options: {}, I: GetIOOutputStateRequest, O: GetIOOutputStateResponse },
    { name: "GetIOInputState", serverStreaming: true, options: {}, I: GetIOInputStateRequest, O: GetIOInputStateResponse },
    { name: "StopGetIOInputState", options: {}, I: StopGetIOInputStateRequest, O: StopGetIOInputStateResponse },
    { name: "SearchMapping", options: {}, I: SearchMappingRequest, O: SearchMappingResponse },
    { name: "GetStreamException", serverStreaming: true, clientStreaming: true, options: {}, I: GetStreamExceptionRequest, O: GetStreamExceptionResponse },
    { name: "GetException", options: {}, I: GetExceptionRequest, O: GetExceptionResponse },
    { name: "DeleteException", options: {}, I: DeleteExceptionRequest, O: DeleteExceptionResponse },
    { name: "SlaveState", serverStreaming: true, clientStreaming: true, options: {}, I: SlaveStateRequest, O: SlaveStateResponse },
    { name: "StartLayoutSimulation", options: {}, I: StartLayoutSimulationRequest, O: StartLayoutSimulationResponse },
    { name: "GetLayoutRobotPositionStream", serverStreaming: true, options: {}, I: GetLayoutRobotPositionRequest, O: GetLayoutRobotPositionResponse },
    { name: "StopGetLayoutRobotPositionStream", options: {}, I: StopGetLayoutRobotPositionRequest, O: StopGetLayoutRobotPositionResponse },
    { name: "SingleAxisZeroCalibrate", options: {}, I: SingleAxisZeroCalibrateRequest, O: SingleAxisZeroCalibrateResponse },
    { name: "MappingCalibrate", options: {}, I: MappingCalibrateRequest, O: MappingCalibrateResponse },
    { name: "MappingSetting", options: {}, I: MappingSettingRequest, O: MappingSettingResponse },
    { name: "SaveMappingSetting", options: {}, I: SaveMappingSettingRequest, O: SaveMappingSettingResponse },
    { name: "SetSolenoid", options: {}, I: SetSolenoidRequest, O: SetSolenoidResponse },
    { name: "GetSolenoid", options: {}, I: GetSolenoidRequest, O: GetSolenoidResponse },
    { name: "GetEnableMapping", options: {}, I: GetEnableMappingRequest, O: GetEnableMappingResponse },
    { name: "SaveEnableMapping", options: {}, I: SaveEnableMappingRequest, O: SaveEnableMappingResponse },
    { name: "RedifyControllerIP", options: {}, I: RedifyControllerIPRequest, O: RedifyControllerIPResponse },
    { name: "GetServoEncode", options: {}, I: GetServoEncodeRequest, O: GetServoEncodeResponse },
    { name: "UpdatePointFile", serverStreaming: true, clientStreaming: true, options: {}, I: UpdatePointFileRequest, O: UpdatePointFileResponse },
    { name: "GetAWCConfig", options: {}, I: GetAWCConfigRequest, O: GetAWCConfigResponse },
    { name: "SaveAWCConfig", options: {}, I: SaveAWCConfigRequest, O: SaveAWCConfigResponse },
    { name: "CalibrateAWCSensor", options: {}, I: CalibrateAWCSensorRequest, O: CalibrateAWCSensorResponse },
    { name: "GetIOInterlockSetting", options: {}, I: GetIOInterlockSettingRequest, O: GetIOInterlockSettingResponse },
    { name: "SaveIOInterlockSetting", options: {}, I: SaveIOInterlockSettingRequest, O: SaveIOInterlockSettingResponse },
    { name: "CalibrateWaferSensor", options: {}, I: CalibrateWaferSensorRequest, O: CalibrateWaferSensorResponse },
    { name: "FindZero", options: {}, I: FindZeroRequest, O: FindZeroResponse },
    { name: "GetStageSetting", options: {}, I: GetStageSettingRequest, O: GetStageSettingResponse },
    { name: "SaveStageSetting", options: {}, I: SaveStageSettingRequest, O: SaveStageSettingResponse },
    { name: "SetRunningMode", options: {}, I: SetRunningModeRequest, O: SetRunningModeResponse },
    { name: "CalibrateRobotParam", options: {}, I: CalibrateRobotParamRequest, O: CalibrateRobotParamResponse }
]);
